import{computed as e,components as t,utils as n,subscribable as r,observableArray as o,observable as u}from"knockout";const c="__ko_decorators_";let s=c+"patched__",i=c+"extenders__",l=c+"subscriptions__";"undefined"!=typeof Symbol&&(s=Symbol(s),i=Symbol(i),l=Symbol(l));const a=Array.prototype;function f(e,t,n){n.configurable=!0,Object.defineProperty(e,t,n)}const b=n.extend,h=n.objectForEach,p=Array.isArray.bind(Array),v=Object.getPrototypeOf.bind(Object),d=Object.getOwnPropertyDescriptor.bind(Object),m=Function.prototype.call.bind(Object.prototype.hasOwnProperty),y=Function.prototype.call.bind(a.slice);function g(e,t){const n=new r,o=function(){const e=y(arguments);n.notifySubscribers(e)};return o.subscribe=function(e){return n.subscribe(function(t){e.apply(null,t)})},f(e,t,{value:o}),o}function w(e,t,n){const r=e[i],o=r&&r[t];return o&&o.forEach(t=>{const r=t instanceof Function?t.call(e):t;n=n.extend(r)}),n}function j(e,t,n){let r=e[i];m(e,i)||(e[i]=r=b({},r),h(r,(e,t)=>{r[e]=[...t]})),(r[t]||(r[t]=[])).push(n)}function _(e,t,n,r){const o=w(e,t,u());let c=o;r&&(c=function(e){o(O(e))}),f(e,t,{enumerable:!0,get:o,set:c}),c(n)}function O(e){if("object"==typeof e){if(p(e)||null===e)return e;if(m(e,"constructor")){const t=v(e);if(t===Object.prototype||null===t)return A(e)}else if(e.constructor===Object)return A(e)}return e}function A(e){return m(e,s)||(f(e,s,{value:!0}),h(e,(t,n)=>{p(n)?F(e,t,n,!0):_(e,t,n,!0)})),e}const k=["pop","reverse","shift","sort"],x=[...k,"push","splice","unshift"],S=["remove","removeAll","destroy","destroyAll","replace","subscribe"],C=[...S,"replace"],E=[...x,...C,"mutate","set"];function F(e,t,n,r){const u=w(e,t,o());let c=!1;function i(e){const t=u.peek();if(t!==e&&(p(t)&&m(t,s)&&(delete t[s],E.forEach(e=>{delete t[e]})),p(e))){if(m(e,s)&&(e=[...e]),r)for(let t=0;t<e.length;++t)e[t]=O(e[t]);f(e,s,{value:!0}),n=e,(r?k:x).forEach(e=>f(n,e,{value(){if(c)return a[e].apply(n,arguments);c=!0;const t=u[e].apply(u,arguments);return c=!1,t}})),(r?S:C).forEach(e=>f(n,e,{value(){c=!0;const t=u[e].apply(u,arguments);return c=!1,t}})),r?(f(n,"push",{value(){if(c)return a.push.apply(n,arguments);const e=y(arguments);for(let t=0;t<e.length;++t)e[t]=O(e[t]);c=!0;const t=u.push.apply(u,e);return c=!1,t}}),f(n,"unshift",{value(){if(c)return a.unshift.apply(n,arguments);const e=y(arguments);for(let t=0;t<e.length;++t)e[t]=O(e[t]);c=!0;const t=u.unshift.apply(u,e);return c=!1,t}}),f(n,"splice",{value(){if(c)return a.splice.apply(n,arguments);let e;switch(c=!0,arguments.length){case 0:case 1:case 2:e=u.splice.apply(u,arguments);break;case 3:e=u.splice(arguments[0],arguments[1],O(arguments[2]));break;default:{const t=y(arguments);for(let e=2;e<t.length;++e)t[e]=O(t[e]);e=u.splice.apply(u,arguments);break}}return c=!1,e}}),f(n,"replace",{value(e,t){c=!0;const n=u.replace(e,O(t));return c=!1,n}}),f(n,"mutate",{value(e){const t=u.peek();u.valueWillMutate(),e(t);for(let e=0;e<t.length;++e)t[e]=O(t[e]);u.valueHasMutated()}}),f(n,"set",{value:(e,t)=>u.splice(e,1,O(t))[0]})):(f(n,"mutate",{value(e){u.valueWillMutate(),e(u.peek()),u.valueHasMutated()}}),f(n,"set",{value:(e,t)=>u.splice(e,1,t)[0]}))}var n;c=!0,u(e),c=!1}f(e,t,{enumerable:!0,get:u,set:i}),i(n)}function M(e,t){return z=!1,N=!1,1===arguments.length?(N=e.deep,B):B(e,t)}function q(e,t){return z=!0,N=!1,1===arguments.length?(N=e.deep,B):B(e,t)}let z,N,V;function B(e,t){const n=z,r=N;f(e,t,{get(){throw new Error("@observable property '"+t.toString()+"' was not initialized")},set(e){n||p(e)?F(this,t,e,r):_(this,t,e,r)}})}function D(e,t,n){return V={pure:!0},1===arguments.length?(V=e,G):G(e,t,n)}function G(t,n,r){const o=V,{get:u,set:c}=r||(r=d(t,n));if(!u)throw new Error("@computed property '"+n.toString()+"' has no getter");return r.get=function(){const t=w(this,n,e(u,this,o));return f(this,n,{get:t,set:c}),t()},r}function H(e){return function(t,n){j(t,n,e)}}function I(e,n,r,o){return void 0===o&&(void 0===r?"object"!=typeof n||n.constructor!==Object||"require"in n||"element"in n||(o=n,n=void 0):"object"==typeof r&&(o=r,r=void 0)),function(r){t.register(e,b({viewModel:r.length<2?r:{createViewModel:(e,{element:t,templateNodes:n})=>new r(e,t,n)},template:n||"\x3c!----\x3e",synchronous:!0},o))}}function J(e,t,n){const{value:r,configurable:o,enumerable:u}=n||(n=d(e,t));return{configurable:o,enumerable:u,get(){if(this===e)return r;const n=r.bind(this);return f(this,t,{value:n}),n}}}function K(e,t){f(e,t,{get(){return g(this,t)}})}function L(t,n,r){const o=r&&r.once||!1;if(m(t,"subscribe")){const e=t;if(o){const t=e.subscribe(function(){t.dispose(),n.apply(null,arguments)});return t}return e.subscribe(n)}{const u=r&&r.event||"change";let c,i;if(c=o?function(){i.dispose(),n.apply(null,arguments)}:n,"arrayChange"===u){const e=t();if(!p(e)||!m(e,s))throw new Error("Can not subscribe to 'arrayChange' because dependency is not an 'observableArray'");i=e.subscribe(c,null,u)}else{const n=e(t),r=(i=n.subscribe(c,null,u)).dispose;i.dispose=function(){r.call(this),n.dispose()}}return i}}function P(e,t){return m(e,t)||e[t],d(e,t).get}function Q(e){return void 0===e&&(e=class{}),class extends e{dispose(){const e=this[l];e&&(e.forEach(e=>{e.dispose()}),delete this[l])}subscribe(){const e=L.apply(null,arguments);return(this[l]||(this[l]=[])).push(e),e}unwrap(e){return P(this,e)}}}export{M as observable,q as observableArray,D as computed,H as extend,I as component,J as autobind,K as event,L as subscribe,P as unwrap,Q as Disposable};
//# sourceMappingURL=knockout-decorators.esm.min.js.map
