{"version":3,"file":null,"sources":["../src/common-functions.ts","../src/event-property.ts","../src/property-extenders.ts","../src/observable-property.ts","../src/observable-array.ts","../src/knockout-decorators.ts"],"sourcesContent":["/**\r\n * Copyright (c) 2016-2017 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\n\r\nconst prefix = \"__ko_decorators_\";\r\n\r\nexport let PATCHED_KEY: string | symbol = prefix + \"patched__\";\r\nexport let EXTENDERS_KEY: string | symbol = prefix + \"extenders__\";\r\nexport let SUBSCRIPTIONS_KEY: string | symbol = prefix + \"subscriptions__\";\r\n\r\nif (typeof Symbol !== \"undefined\") {\r\n    PATCHED_KEY = Symbol(PATCHED_KEY);\r\n    EXTENDERS_KEY = Symbol(EXTENDERS_KEY);\r\n    SUBSCRIPTIONS_KEY = Symbol(SUBSCRIPTIONS_KEY);\r\n}\r\n\r\nexport function defineProperty(instance: Object, key: any, descriptor: PropertyDescriptor) {\r\n    descriptor.configurable = true;\r\n    Object.defineProperty(instance, key, descriptor);\r\n}\r\n\r\nexport const extendObject = ko.utils.extend;\r\nexport const objectForEach = ko.utils.objectForEach;\r\nexport const getPrototypeOf = Object.getPrototypeOf.bind(Object);\r\nexport const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor.bind(Object);\r\nexport const hasOwnProperty = Function.prototype.call.bind(Object.prototype.hasOwnProperty);\r\nexport const arraySlice = Function.prototype.call.bind(Array.prototype.slice);\r\n","/**\r\n * Copyright (c) 2016-2017 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\nimport { arraySlice, defineProperty } from \"./common-functions\";\r\nimport { EventType } from \"./knockout-decorators\";\r\n\r\nexport function defineEventProperty(instance: Object, key: string | symbol) {\r\n    const subscribable = new ko.subscribable<any[]>();\r\n\r\n    const event: EventType = function () {\r\n        const eventArgs = arraySlice(arguments);\r\n        subscribable.notifySubscribers(eventArgs);\r\n    } as any;\r\n\r\n    event.subscribe = function (callback: Function) {\r\n        return subscribable.subscribe(function (eventArgs: any[]) {\r\n            callback.apply(null, eventArgs);\r\n        });\r\n    };\r\n\r\n    defineProperty(instance, key, {\r\n        value: event,\r\n    });\r\n\r\n    return event;\r\n}\r\n","/**\r\n * Copyright (c) 2016-2017 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport { EXTENDERS_KEY, extendObject, hasOwnProperty, objectForEach } from \"./common-functions\";\r\n\r\ntype Extender = Object | Function;\r\n\r\ninterface ExtendersDictionary {\r\n    [propName: string]: Extender[];\r\n}\r\n\r\nexport function applyExtenders(\r\n    instance: Object, key: string | symbol,\r\n    target: KnockoutObservable<any> | KnockoutComputed<any>,\r\n) {\r\n    const dictionary = instance[EXTENDERS_KEY] as ExtendersDictionary;\r\n    const extenders = dictionary && dictionary[key];\r\n    if (extenders) {\r\n        extenders.forEach((extender) => {\r\n            const koExtender = extender instanceof Function\r\n                ? extender.call(instance) : extender;\r\n\r\n            target = target.extend(koExtender);\r\n        });\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function defineExtenders(\r\n    prototype: Object, key: string | symbol,\r\n    extendersOrFactory: Object | Function,\r\n) {\r\n    let dictionary = prototype[EXTENDERS_KEY] as ExtendersDictionary;\r\n    // if there is no ExtendersDictionary or ExtendersDictionary lives in base class prototype\r\n    if (!hasOwnProperty(prototype, EXTENDERS_KEY)) {\r\n        // clone ExtendersDictionary from base class prototype or create new ExtendersDictionary\r\n        prototype[EXTENDERS_KEY] = dictionary = extendObject({}, dictionary) as ExtendersDictionary;\r\n        // clone Extenders arrays for each property key\r\n        objectForEach(dictionary, (existingKey, extenders) => {\r\n            dictionary[existingKey] = [...extenders];\r\n        });\r\n    }\r\n    // get existing Extenders array or create new array\r\n    const extenders = dictionary[key] || (dictionary[key] = []);\r\n    // add new Extenders\r\n    extenders.push(extendersOrFactory);\r\n}\r\n","/**\r\n * Copyright (c) 2016-2017 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\nimport { defineProperty, getPrototypeOf, hasOwnProperty, objectForEach, PATCHED_KEY } from \"./common-functions\";\r\nimport { defineObservableArray } from \"./observable-array\";\r\nimport { applyExtenders } from \"./property-extenders\";\r\n\r\nexport function defineObservableProperty(\r\n    instance: Object, key: string | symbol, value: any, deep: boolean,\r\n) {\r\n    const observable = applyExtenders(instance, key, ko.observable());\r\n\r\n    let setter = observable as any;\r\n\r\n    if (deep) {\r\n        setter = function (newValue: any) {\r\n            observable(prepareReactiveValue(newValue));\r\n        };\r\n    }\r\n\r\n    defineProperty(instance, key, {\r\n        enumerable: true,\r\n        get: observable,\r\n        set: setter,\r\n    });\r\n\r\n    setter(value);\r\n}\r\n\r\nexport function prepareReactiveValue(value: any) {\r\n    if (typeof value === \"object\") {\r\n        if (Array.isArray(value) || value === null) {\r\n            // value is Array or null\r\n            return value;\r\n        } else if (value.constructor === Object) {\r\n            // value is plain Object\r\n            return prepareReactiveObject(value);\r\n        } else if (hasOwnProperty(value, \"constructor\")) {\r\n            const prototype = getPrototypeOf(value);\r\n            if (prototype === Object.prototype || prototype === null) {\r\n                // value is plain Object\r\n                return prepareReactiveObject(value);\r\n            }\r\n        }\r\n    }\r\n    // value is primitive, function or class instance\r\n    return value;\r\n}\r\n\r\nexport function prepareReactiveObject(instance: Object) {\r\n    if (!hasOwnProperty(instance, PATCHED_KEY)) {\r\n        // mark instance as ObservableObject\r\n        defineProperty(instance, PATCHED_KEY, {\r\n            value: true,\r\n        });\r\n        // define deep observable properties\r\n        objectForEach(instance, (key, value) => {\r\n            if (Array.isArray(value)) {\r\n                defineObservableArray(instance, key, value, true);\r\n            } else {\r\n                defineObservableProperty(instance, key, value, true);\r\n            }\r\n        });\r\n    }\r\n    return instance;\r\n}\r\n","/**\r\n * Copyright (c) 2016-2017 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\nimport { arraySlice, defineProperty, hasOwnProperty, PATCHED_KEY } from \"./common-functions\";\r\nimport { prepareReactiveValue } from \"./observable-property\";\r\nimport { applyExtenders } from \"./property-extenders\";\r\n\r\ntype ObsArray = KnockoutObservableArray<any> & { [fnName: string]: Function };\r\n\r\nconst deepArrayMethods = [\"pop\", \"reverse\", \"shift\", \"sort\"];\r\nconst allArrayMethods = [...deepArrayMethods, \"push\", \"splice\", \"unshift\"];\r\n\r\nconst deepObservableArrayMethods = [\"remove\", \"removeAll\", \"destroy\", \"destroyAll\", \"replace\", \"subscribe\"];\r\nconst allObservableArrayMethods = [...deepObservableArrayMethods, \"replace\"];\r\n\r\nconst allMethods = [...allArrayMethods, ...allObservableArrayMethods, \"mutate\", \"set\"];\r\n\r\nexport function defineObservableArray(\r\n    instance: Object, key: string | symbol, value: any[], deep: boolean,\r\n) {\r\n    const obsArray = applyExtenders(instance, key, ko.observableArray()) as ObsArray;\r\n\r\n    let insideObsArray = false;\r\n\r\n    defineProperty(instance, key, {\r\n        enumerable: true,\r\n        get: obsArray,\r\n        set: setter,\r\n    });\r\n\r\n    setter(value);\r\n\r\n    function setter(newValue: any[]) {\r\n        const lastValue = obsArray.peek();\r\n        // if we got new value\r\n        if (lastValue !== newValue) {\r\n            if (Array.isArray(lastValue)) {\r\n                // if lastValue array methods were already patched\r\n                if (hasOwnProperty(lastValue, PATCHED_KEY)) {\r\n                    delete lastValue[PATCHED_KEY];\r\n                    // clear patched array methods on lastValue (see unit tests)\r\n                    allMethods.forEach((fnName) => {\r\n                        delete lastValue[fnName];\r\n                    });\r\n                }\r\n            }\r\n            if (Array.isArray(newValue)) {\r\n                // if new value array methods were already connected with another @observable\r\n                if (hasOwnProperty(newValue, PATCHED_KEY)) {\r\n                    // clone new value to prevent corruption of another @observable (see unit tests)\r\n                    newValue = [...newValue];\r\n                }\r\n                // if deep option is set\r\n                if (deep) {\r\n                    // make all array items reactive\r\n                    for (let i = 0; i < newValue.length; ++i) {\r\n                        newValue[i] = prepareReactiveValue(newValue[i]);\r\n                    }\r\n                }\r\n                // mark instance as ObservableArray\r\n                defineProperty(newValue, PATCHED_KEY, {\r\n                    value: true,\r\n                });\r\n                // call ko.observableArray.fn[fnName] instead of Array.prototype[fnName]\r\n                patchArrayMethods(newValue);\r\n            }\r\n        }\r\n        // update obsArray contents\r\n        insideObsArray = true;\r\n        obsArray(newValue);\r\n        insideObsArray = false;\r\n    }\r\n\r\n    function patchArrayMethods(array: any[]) {\r\n        const arrayMethods = deep ? deepArrayMethods : allArrayMethods;\r\n\r\n        arrayMethods.forEach((fnName) => defineProperty(array, fnName, {\r\n            value() {\r\n                if (insideObsArray) {\r\n                    return Array.prototype[fnName].apply(array, arguments);\r\n                }\r\n                insideObsArray = true;\r\n                const result = obsArray[fnName].apply(obsArray, arguments);\r\n                insideObsArray = false;\r\n                return result;\r\n            },\r\n        }));\r\n\r\n        const observableArrayMethods = deep ? deepObservableArrayMethods : allObservableArrayMethods;\r\n\r\n        observableArrayMethods.forEach((fnName) => defineProperty(array, fnName, {\r\n            value() {\r\n                insideObsArray = true;\r\n                const result = obsArray[fnName].apply(obsArray, arguments);\r\n                insideObsArray = false;\r\n                return result;\r\n            },\r\n        }));\r\n\r\n        if (deep) {\r\n            defineProperty(array, \"push\", {\r\n                value() {\r\n                    if (insideObsArray) {\r\n                        return Array.prototype.push.apply(array, arguments);\r\n                    }\r\n                    let args = arraySlice(arguments);\r\n                    for (let i = 0; i < args.length; ++i) {\r\n                        args[i] = prepareReactiveValue(args[i]);\r\n                    }\r\n                    insideObsArray = true;\r\n                    const result = obsArray.push.apply(obsArray, args);\r\n                    insideObsArray = false;\r\n                    return result;\r\n                },\r\n            });\r\n\r\n            defineProperty(array, \"unshift\", {\r\n                value() {\r\n                    if (insideObsArray) {\r\n                        return Array.prototype.unshift.apply(array, arguments);\r\n                    }\r\n                    let args = arraySlice(arguments);\r\n                    for (let i = 0; i < args.length; ++i) {\r\n                        args[i] = prepareReactiveValue(args[i]);\r\n                    }\r\n                    insideObsArray = true;\r\n                    const result = obsArray.unshift.apply(obsArray, args);\r\n                    insideObsArray = false;\r\n                    return result;\r\n                },\r\n            });\r\n\r\n            defineProperty(array, \"splice\", {\r\n                value() {\r\n                    if (insideObsArray) {\r\n                        return Array.prototype.splice.apply(array, arguments);\r\n                    }\r\n\r\n                    let result: any[];\r\n\r\n                    insideObsArray = true;\r\n                    switch (arguments.length) {\r\n                        case 0:\r\n                        case 1:\r\n                        case 2: {\r\n                            result = obsArray.splice.apply(obsArray, arguments);\r\n                            break;\r\n                        }\r\n                        case 3: {\r\n                            result = obsArray.splice(\r\n                                arguments[0], arguments[1], prepareReactiveValue(arguments[2]),\r\n                            );\r\n                            break;\r\n                        }\r\n                        default: {\r\n                            const args = arraySlice(arguments);\r\n                            for (let i = 2; i < args.length; ++i) {\r\n                                args[i] = prepareReactiveValue(args[i]);\r\n                            }\r\n                            result = obsArray.splice.apply(obsArray, arguments);\r\n                            break;\r\n                        }\r\n                    }\r\n                    insideObsArray = false;\r\n\r\n                    return result;\r\n                },\r\n            });\r\n\r\n            defineProperty(array, \"replace\", {\r\n                value(oldItem: any, newItem: any) {\r\n                    insideObsArray = true;\r\n                    const result = obsArray.replace(oldItem, prepareReactiveValue(newItem));\r\n                    insideObsArray = false;\r\n                    return result;\r\n                },\r\n            });\r\n\r\n            defineProperty(array, \"mutate\", {\r\n                value(mutator: (array?: any[]) => void) {\r\n                    const nativeArray = obsArray.peek();\r\n                    // it is defined for ko.observableArray\r\n                    (obsArray.valueWillMutate as Function)();\r\n                    mutator(nativeArray);\r\n                    for (let i = 0; i < nativeArray.length; ++i) {\r\n                        nativeArray[i] = prepareReactiveValue(nativeArray[i]);\r\n                    }\r\n                    // it is defined for ko.observableArray\r\n                    (obsArray.valueHasMutated as Function)();\r\n                },\r\n            });\r\n\r\n            defineProperty(array, \"set\", {\r\n                value(index: number, newItem: any) {\r\n                    return obsArray.splice(index, 1, prepareReactiveValue(newItem))[0];\r\n                },\r\n            });\r\n        } else {\r\n            defineProperty(array, \"mutate\", {\r\n                value(mutator: (array?: any[]) => void) {\r\n                    // it is defined for ko.observableArray\r\n                    (obsArray.valueWillMutate as Function)();\r\n                    mutator(obsArray.peek());\r\n                    // it is defined for ko.observableArray\r\n                    (obsArray.valueHasMutated as Function)();\r\n                },\r\n            });\r\n\r\n            defineProperty(array, \"set\", {\r\n                value(index: number, newItem: any) {\r\n                    return obsArray.splice(index, 1, newItem)[0];\r\n                },\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport interface ObservableArray<T> extends Array<T> {\r\n    replace(oldItem: T, newItem: T): void;\r\n\r\n    remove(item: T): T[];\r\n    remove(removeFunction: (item: T) => boolean): T[];\r\n\r\n    removeAll(): T[];\r\n    removeAll(items: T[]): T[];\r\n\r\n    destroy(item: T): void;\r\n    destroy(destroyFunction: (item: T) => boolean): void;\r\n\r\n    destroyAll(): void;\r\n    destroyAll(items: T[]): void;\r\n\r\n    subscribe(callback: (val: T[]) => void): KnockoutSubscription;\r\n    subscribe(callback: (val: T[]) => void, callbackTarget: any): KnockoutSubscription;\r\n    subscribe(callback: (val: any[]) => void, callbackTarget: any, event: string): KnockoutSubscription;\r\n\r\n    /**\r\n     * Run mutator function that can write to array at some index (`array[index] = value;`)\r\n     * Then notify about observableArray changes\r\n     */\r\n    mutate(mutator: (arrayValue: T[]) => void): void;\r\n\r\n    /**\r\n     * Replace value at some index and return old value\r\n     */\r\n    set(index: number, value: T): T;\r\n}\r\n","/**\r\n * Copyright (c) 2016-2017 Dmitry Panyushkin\r\n * Available under MIT license\r\n * Version: 0.10.0\r\n */\r\nimport * as ko from \"knockout\";\r\nimport {\r\n    defineProperty, extendObject, getOwnPropertyDescriptor, hasOwnProperty, PATCHED_KEY, SUBSCRIPTIONS_KEY,\r\n} from \"./common-functions\";\r\nimport { defineEventProperty } from \"./event-property\";\r\nimport { defineObservableArray } from \"./observable-array\";\r\nimport { defineObservableProperty } from \"./observable-property\";\r\nimport { applyExtenders, defineExtenders } from \"./property-extenders\";\r\n\r\n/**\r\n * Property decorator that creates hidden (shallow) ko.observable with ES6 getter and setter for it\r\n * If initialized by Array then hidden (shallow) ko.observableArray will be created\r\n */\r\nexport function observable(prototype: Object, key: string | symbol) {\r\n    defineProperty(prototype, key, {\r\n        get() {\r\n            throw new Error(\"@observable property '\" + key.toString() + \"' was not initialized\");\r\n        },\r\n        set(this: Object, value: any) {\r\n            if (Array.isArray(value)) {\r\n                defineObservableArray(this, key, value, false);\r\n            } else {\r\n                defineObservableProperty(this, key, value, false);\r\n            }\r\n        },\r\n    });\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Property decorator that creates hidden (deep) ko.observable with ES6 getter and setter for it\r\n * If initialized by Array then hidden (deep) ko.observableArray will be created\r\n */\r\nexport function reactive(prototype: Object, key: string | symbol) {\r\n    defineProperty(prototype, key, {\r\n        get() {\r\n            throw new Error(\"@reactive property '\" + key.toString() + \"' was not initialized\");\r\n        },\r\n        set(this: Object, value: any) {\r\n            if (Array.isArray(value)) {\r\n                defineObservableArray(this, key, value, true);\r\n            } else {\r\n                defineObservableProperty(this, key, value, true);\r\n            }\r\n        },\r\n    });\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Accessor decorator that wraps ES6 getter to hidden ko.pureComputed\r\n *\r\n * Setter is not wrapped to hidden ko.pureComputed and stays unchanged\r\n *\r\n * But we can still extend getter @computed by extenders like { rateLimit: 500 }\r\n */\r\nexport function computed(prototype: Object, key: string | symbol, desc: PropertyDescriptor) {\r\n    const { get, set } = desc || (desc = getOwnPropertyDescriptor(prototype, key));\r\n    if (!get) {\r\n        throw new Error(\"@computed property '\" + key.toString() + \"' has no getter\");\r\n    }\r\n    desc.get = function (this: Object) {\r\n        const computed = applyExtenders(this, key, ko.pureComputed(get, this));\r\n        defineProperty(this, key, {\r\n            get: computed,\r\n            // tslint:disable-next-line:object-literal-shorthand\r\n            set: set,\r\n        });\r\n        return computed();\r\n    };\r\n    return desc;\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Property decorator that creates hidden (shallow) ko.observableArray with ES6 getter and setter for it\r\n */\r\nexport function observableArray(prototype: Object, key: string | symbol) {\r\n    defineProperty(prototype, key, {\r\n        get() {\r\n            throw new Error(\"@observableArray property '\" + key.toString() + \"' was not initialized\");\r\n        },\r\n        set(this: Object, value: any[]) {\r\n            defineObservableArray(this, key, value, false);\r\n        },\r\n    });\r\n}\r\n\r\nexport interface ObservableArray<T> extends Array<T> {\r\n    replace(oldItem: T, newItem: T): void;\r\n\r\n    remove(item: T): T[];\r\n    remove(removeFunction: (item: T) => boolean): T[];\r\n\r\n    removeAll(): T[];\r\n    removeAll(items: T[]): T[];\r\n\r\n    destroy(item: T): void;\r\n    destroy(destroyFunction: (item: T) => boolean): void;\r\n\r\n    destroyAll(): void;\r\n    destroyAll(items: T[]): void;\r\n\r\n    subscribe(callback: (val: T[]) => void): KnockoutSubscription;\r\n    subscribe(callback: (val: T[]) => void, callbackTarget: any): KnockoutSubscription;\r\n    subscribe(callback: (val: any[]) => void, callbackTarget: any, event: string): KnockoutSubscription;\r\n\r\n    /**\r\n     * Run mutator function that can write to array at some index (`array[index] = value;`)\r\n     * Then notify about observableArray changes\r\n     */\r\n    mutate(mutator: (arrayValue: T[]) => void): void;\r\n\r\n    /**\r\n     * Replace value at some index and return old value\r\n     */\r\n    set(index: number, value: T): T;\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Apply extenders to decorated @observable\r\n */\r\nexport function extend(extenders: Object): PropertyDecorator;\r\n/**\r\n * Apply extenders to decorated @observable\r\n */\r\nexport function extend(extendersFactory: () => Object): PropertyDecorator;\r\n/**\r\n * Apply extenders to decorated @observable\r\n * @extendersOrFactory { Object | Function } Knockout extenders definition or factory that produces definition\r\n */\r\nexport function extend(extendersOrFactory: Object | Function) {\r\n    return function (prototype: Object, key: string | symbol) {\r\n        defineExtenders(prototype, key, extendersOrFactory);\r\n    };\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\nexport interface ComponentConstructor {\r\n    new (\r\n        params?: any,\r\n        element?: Node,\r\n        templateNodes?: Node[],\r\n    ): any;\r\n}\r\n\r\nexport type ComponentDecorator = (constructor: ComponentConstructor) => void;\r\n\r\nexport type TemplateConfig = (\r\n    string\r\n    | Node[]\r\n    | DocumentFragment\r\n    | { require: string }\r\n    | { element: string | Node }\r\n);\r\n\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n    name: string,\r\n    options?: Object,\r\n): ComponentDecorator;\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    options?: Object,\r\n): ComponentDecorator;\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    styles: string | string[],\r\n    options?: Object,\r\n): ComponentDecorator;\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n * @param name {String} Name of component\r\n * @param template {Any} Knockout template definition\r\n * @param styles {Any} Ignored parameter (used for `require()` styles by webpack etc.)\r\n * @param options {Object} Another options that passed directly to `ko.components.register()`\r\n */\r\nexport function component(\r\n    name: string,\r\n    template?: any,\r\n    styles?: any,\r\n    options?: Object,\r\n) {\r\n    if (options === void 0) {\r\n        if (styles === void 0) {\r\n            if (typeof template === \"object\"\r\n                && template.constructor === Object\r\n                && !(\"require\" in template)\r\n                && !(\"element\" in template)\r\n            ) {\r\n                options = template;\r\n                template = void 0;\r\n            }\r\n        } else if (typeof styles === \"object\") {\r\n            options = styles;\r\n            styles = void 0;\r\n        }\r\n    }\r\n\r\n    return function (constructor: ComponentConstructor) {\r\n        ko.components.register(name, extendObject({\r\n            viewModel: constructor.length < 2 ? constructor : {\r\n                createViewModel(params: any, {\r\n                    element, templateNodes,\r\n                }: {\r\n                        element: Node, templateNodes: Node[],\r\n                    }) {\r\n                    return new constructor(params, element, templateNodes);\r\n                },\r\n            },\r\n            template: template || \"<!---->\",\r\n            synchronous: true,\r\n        }, options as Object));\r\n    };\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Like https://github.com/jayphelps/core-decorators.js @autobind but less smart and complex\r\n * Do NOT use with ES6 inheritance!\r\n */\r\nexport function autobind(prototype: Object, key: string | symbol, desc: PropertyDescriptor) {\r\n    const { value, configurable, enumerable } = desc || (desc = getOwnPropertyDescriptor(prototype, key));\r\n    return {\r\n        // tslint:disable-next-line:object-literal-shorthand\r\n        configurable: configurable,\r\n        // tslint:disable-next-line:object-literal-shorthand\r\n        enumerable: enumerable,\r\n        get(this: Object) {\r\n            if (this === prototype) {\r\n                return value;\r\n            }\r\n            const bound = value.bind(this);\r\n            defineProperty(this, key, {\r\n                value: bound,\r\n            });\r\n            return bound;\r\n        },\r\n    } as PropertyDescriptor;\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Define hidden ko.subscribable, that notifies subscribers when decorated method is invoked\r\n */\r\nexport function event(prototype: Object, key: string | symbol) {\r\n    defineProperty(prototype, key, {\r\n        get(this: Object) {\r\n            return defineEventProperty(this, key);\r\n        },\r\n    });\r\n}\r\n\r\nexport type EventType = Function & {\r\n    subscribe(callback: Function): KnockoutSubscription;\r\n};\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Subscribe callback to `@observable` or `@computed` dependency changes or to some `@event` property\r\n */\r\nexport function subscribe<T>(\r\n    dependencyOrEvent: () => T,\r\n    callback: (value: T) => void,\r\n    options?: { once?: boolean, event?: \"change\" | \"beforeChange\" },\r\n): KnockoutSubscription;\r\n/**\r\n * Subscribe callback to `@observableArray` dependency \"arrayChange\" event\r\n */\r\nexport function subscribe<T>(\r\n    dependency: () => T[],\r\n    callback: (value: {\r\n        status: \"added\" | \"deleted\";\r\n        value: T;\r\n        index: number;\r\n    }[]) => void,\r\n    options: { once?: boolean, event: \"arrayChange\" },\r\n): KnockoutSubscription;\r\n/**\r\n * Subscribe callback to some `@event` property\r\n */\r\nexport function subscribe<T>(\r\n    event: (arg: T) => void,\r\n    callback: (arg: T) => void,\r\n    options?: { once?: boolean },\r\n): KnockoutSubscription;\r\n/**\r\n * Subscribe callback to some `@event` property\r\n */\r\nexport function subscribe<T1, T2>(\r\n    event: (arg1: T1, arg2: T2) => void,\r\n    callback: (arg1: T1, arg2: T2) => void,\r\n    options?: { once?: boolean },\r\n): KnockoutSubscription;\r\n/**\r\n * Subscribe callback to some `@event` property\r\n */\r\nexport function subscribe<T1, T2, T3>(\r\n    event: (arg1: T1, arg2: T2, arg3: T3, ...args: any[]) => void,\r\n    callback: (arg1: T1, arg2: T2, arg3: T3, ...args: any[]) => void,\r\n    options?: { once?: boolean },\r\n): KnockoutSubscription;\r\n/**\r\n * Subscribe callback to `@observable` or `@computed` dependency changes or to some `@event`\r\n */\r\nexport function subscribe(\r\n    dependencyOrEvent: Function,\r\n    callback: (...args: any[]) => void,\r\n    options?: { once?: boolean, event?: \"change\" | \"beforeChange\" | \"arrayChange\" },\r\n) {\r\n    const once = options && options.once || false;\r\n\r\n    if (hasOwnProperty(dependencyOrEvent, \"subscribe\")) {\r\n        // overload: subscribe to @event property\r\n        const event = dependencyOrEvent as EventType;\r\n\r\n        if (once) {\r\n            const subscription = event.subscribe(function () {\r\n                subscription.dispose();\r\n                callback.apply(null, arguments);\r\n            });\r\n            return subscription;\r\n        } else {\r\n            return event.subscribe(callback);\r\n        }\r\n    } else {\r\n        // overload: subscribe to @observable, @reactive or @computed\r\n        const event = options && options.event || \"change\";\r\n\r\n        let handler: (value: any) => void;\r\n        let subscription: KnockoutSubscription;\r\n\r\n        if (once) {\r\n            handler = function () {\r\n                subscription.dispose();\r\n                callback.apply(null, arguments);\r\n            };\r\n        } else {\r\n            handler = callback;\r\n        }\r\n\r\n        if (event === \"arrayChange\") {\r\n            const obsArray = dependencyOrEvent() as ObservableArray<any>;\r\n\r\n            if (Array.isArray(obsArray) && hasOwnProperty(obsArray, PATCHED_KEY)) {\r\n                subscription = obsArray.subscribe(handler, null, event);\r\n            } else {\r\n                throw new Error(\"Can not subscribe to 'arrayChange' because dependency is not an 'observableArray'\");\r\n            }\r\n        } else {\r\n            const computed = ko.computed(dependencyOrEvent as () => any);\r\n\r\n            subscription = computed.subscribe(handler, null, event);\r\n\r\n            const originalDispose = subscription.dispose;\r\n            // dispose hidden computed with subscription\r\n            subscription.dispose = function (this: KnockoutSubscription) {\r\n                originalDispose.call(this);\r\n                computed.dispose();\r\n            };\r\n        }\r\n        return subscription;\r\n    }\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap(instance: Object, key: string | symbol): any;\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap<T>(instance: Object, key: string | symbol): KnockoutObservable<T>;\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap(instance: Object, key: string | symbol) {\r\n    if (!hasOwnProperty(instance, key)) {\r\n        // invoke getter on instance.__proto__ that defines property on instance\r\n        // tslint:disable-next-line:no-unused-expression\r\n        instance[key];\r\n    }\r\n    return getOwnPropertyDescriptor(instance, key).get;\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n/**\r\n * Mixin which add `subscribe()` instance method and implement `dispose()` method,\r\n * that disposes all subscription created by `subscribe()`\r\n */\r\nexport interface Disposable {\r\n    /** Dispose all subscriptions from this class */\r\n    dispose(): void;\r\n\r\n    /** Subscribe callback to `@observable` or `@computed` dependency changes or to some `@event` property */\r\n    subscribe<T>(\r\n        dependencyOrEvent: () => T,\r\n        callback: (value: T) => void,\r\n        options?: { once?: boolean, event?: \"change\" | \"beforeChange\" },\r\n    ): KnockoutSubscription;\r\n    /** Subscribe callback to `@observableArray` dependency \"arrayChange\" event */\r\n    subscribe<T>(\r\n        dependency: () => T[],\r\n        callback: (value: {\r\n            status: \"added\" | \"deleted\";\r\n            value: T;\r\n            index: number;\r\n        }[]) => void,\r\n        options: { once?: boolean, event: \"arrayChange\" },\r\n    ): KnockoutSubscription;\r\n    /** Subscribe callback to some `@event` property */\r\n    subscribe<T>(\r\n        event: (arg: T) => void,\r\n        callback: (arg: T) => void,\r\n        options?: { once?: boolean },\r\n    ): KnockoutSubscription;\r\n    /** Subscribe callback to some `@event` property */\r\n    subscribe<T1, T2>(\r\n        event: (arg1: T1, arg2: T2) => void,\r\n        callback: (arg1: T1, arg2: T2) => void,\r\n        options?: { once?: boolean },\r\n    ): KnockoutSubscription;\r\n    /** Subscribe callback to some `@event` property */\r\n    subscribe<T1, T2, T3>(\r\n        event: (arg1: T1, arg2: T2, arg3: T3, ...args: any[]) => void,\r\n        callback: (arg1: T1, arg2: T2, arg3: T3, ...args: any[]) => void,\r\n        options?: { once?: boolean },\r\n    ): KnockoutSubscription;\r\n\r\n    /** Get internal ko.observable() for class property decodated by `@observable` */\r\n    unwrap(key: string | symbol): any;\r\n    /** Get internal ko.observable() for class property decodated by `@observable` */\r\n    unwrap<T>(key: string | symbol): KnockoutObservable<T>;\r\n}\r\n\r\n/**\r\n * Mixin which add `subscribe()` instance method and implement `dispose()` method,\r\n * that disposes all subscription created by `subscribe()`\r\n * @param Base {Function} Base class to extend\r\n */\r\nexport function Disposable<T extends new (...args: any[]) => {}>(\r\n    // tslint:disable-next-line:variable-name\r\n    Base?: T,\r\n): (new (...args: any[]) => Disposable) & T {\r\n    if (typeof Base === \"undefined\") {\r\n        Base = class { } as T;\r\n    }\r\n    return class extends Base {\r\n        constructor(...args: any[]) {\r\n            super(...args);\r\n        }\r\n\r\n        /** Dispose all subscriptions from this class */\r\n        dispose() {\r\n            const subscriptions: KnockoutSubscription[] = this[SUBSCRIPTIONS_KEY];\r\n            if (subscriptions) {\r\n                subscriptions.forEach((subscription) => {\r\n                    subscription.dispose();\r\n                });\r\n            }\r\n        }\r\n\r\n        /** Subscribe callback to `@observable` or `@computed` dependency changes or to some `@event` */\r\n        subscribe() {\r\n            const subscription: KnockoutSubscription = subscribe.apply(null, arguments);\r\n            const subscriptions: KnockoutSubscription[] = this[SUBSCRIPTIONS_KEY] || (this[SUBSCRIPTIONS_KEY] = []);\r\n            subscriptions.push(subscription);\r\n            return subscription;\r\n        }\r\n\r\n        /** Get internal ko.observable() for class property decodated by `@observable` */\r\n        unwrap(key: string) {\r\n            return unwrap(this, key);\r\n        }\r\n    };\r\n}\r\n"],"names":["instance","key","descriptor","configurable","Object","defineProperty","subscribable","ko.subscribable","event","eventArgs","arraySlice","arguments","notifySubscribers","subscribe","callback","apply","value","target","dictionary","EXTENDERS_KEY","extenders","forEach","extender","koExtender","Function","call","extend","prototype","extendersOrFactory","hasOwnProperty","extendObject","objectForEach","existingKey","push","deep","observable","applyExtenders","ko.observable","setter","newValue","prepareReactiveValue","enumerable","get","set","Array","isArray","constructor","prepareReactiveObject","getPrototypeOf","PATCHED_KEY","defineObservableArray","defineObservableProperty","lastValue","obsArray","peek","allMethods","fnName","i","length","patchArrayMethods","insideObsArray","array","arrayMethods","deepArrayMethods","allArrayMethods","result","observableArrayMethods","deepObservableArrayMethods","allObservableArrayMethods","args","unshift","splice","oldItem","newItem","replace","mutator","nativeArray","valueWillMutate","valueHasMutated","index","ko.observableArray","Error","toString","this","desc","_a","computed","ko.pureComputed","defineExtenders","name","template","styles","options","ko.components","register","viewModel","createViewModel","params","element","templateNodes","synchronous","bound","bind","defineEventProperty","dependencyOrEvent","once","event_1","subscription_1","dispose","subscription_2","event_2","handler","computed_1","ko.computed","originalDispose_1","getOwnPropertyDescriptor","Base","_i","__extends","class_2","subscriptions","SUBSCRIPTIONS_KEY","subscription","unwrap","prefix","Symbol","ko.utils","slice"],"mappings":"uaAkBA,WAA+BA,EAAkBC,EAAUC,GACvDA,EAAWC,cAAe,EAC1BC,OAAOC,eAAeL,EAAUC,EAAKC,GChBzC,WAIoCF,EAAkBC,GAClD,GAAMK,GAAe,GAAIC,gBAEnBC,EAAmB,WACrB,GAAMC,GAAYC,EAAWC,UAC7BL,GAAaM,kBAAkBH,GAanC,OAVAD,GAAMK,UAAY,SAAUC,GACxB,MAAOR,GAAaO,UAAU,SAAUJ,GACpCK,EAASC,MAAM,KAAMN,MAI7BJ,EAAeL,EAAUC,GACrBe,MAAOR,IAGJA,ECtBX,WASIR,EAAkBC,EAClBgB,GAEA,GAAMC,GAAalB,EAASmB,GACtBC,EAAYF,GAAcA,EAAWjB,EAS3C,OARImB,IACAA,EAAUC,QAAQ,SAACC,GACf,GAAMC,GAAaD,YAAoBE,UACjCF,EAASG,KAAKzB,GAAYsB,CAEhCL,GAASA,EAAOS,OAAOH,KAGxBN,EAGX,WACIU,EAAmB1B,EACnB2B,GAEA,GAAIV,GAAaS,EAAUR,EAEtBU,GAAeF,EAAWR,KAE3BQ,EAAUR,GAAiBD,EAAaY,KAAiBZ,GAEzDa,EAAcb,EAAY,SAACc,EAAaZ,GACpCF,EAAWc,GAAmBZ,YAItC,IAAMA,GAAYF,EAAWjB,KAASiB,EAAWjB,MAEjDmB,GAAUa,KAAKL,GC1CnB,WAMI5B,EAAkBC,EAAsBe,EAAYkB,GAEpD,GAAMC,GAAaC,EAAepC,EAAUC,EAAKoC,gBAE7CC,EAASH,CAETD,KACAI,EAAS,SAAUC,GACfJ,EAAWK,EAAqBD,MAIxClC,EAAeL,EAAUC,GACrBwC,YAAY,EACZC,IAAKP,EACLQ,IAAKL,IAGTA,EAAOtB,GAGX,WAAqCA,GACjC,GAAqB,gBAAVA,GAAoB,CAC3B,GAAI4B,MAAMC,QAAQ7B,IAAoB,OAAVA,EAExB,MAAOA,EACJ,IAAIA,EAAM8B,cAAgB1C,OAE7B,MAAO2C,GAAsB/B,EAC1B,IAAIa,EAAeb,EAAO,eAAgB,CAC7C,GAAMW,GAAYqB,EAAehC,EACjC,IAAIW,IAAcvB,OAAOuB,WAA2B,OAAdA,EAElC,MAAOoB,GAAsB/B,IAKzC,MAAOA,GAGX,WAAsChB,GAelC,MAdK6B,GAAe7B,EAAUiD,KAE1B5C,EAAeL,EAAUiD,GACrBjC,OAAO,IAGXe,EAAc/B,EAAU,SAACC,EAAKe,GACtB4B,MAAMC,QAAQ7B,GACdkC,EAAsBlD,EAAUC,EAAKe,GAAO,GAE5CmC,EAAyBnD,EAAUC,EAAKe,GAAO,MAIpDhB,EC/CX,WACIA,EAAkBC,EAAsBe,EAAckB,GActD,WAAgBK,GACZ,GAAMa,GAAYC,EAASC,MAE3B,IAAIF,IAAcb,IACVK,MAAMC,QAAQO,IAEVvB,EAAeuB,EAAWH,WACnBG,GAAUH,GAEjBM,EAAWlC,QAAQ,SAACmC,SACTJ,GAAUI,MAIzBZ,MAAMC,QAAQN,IAAW,CAOzB,GALIV,EAAeU,EAAUU,KAEzBV,EAAeA,WAGfL,EAEA,IAAK,GAAIuB,GAAI,EAAGA,EAAIlB,EAASmB,SAAUD,EACnClB,EAASkB,GAAKjB,EAAqBD,EAASkB,GAIpDpD,GAAekC,EAAUU,GACrBjC,OAAO,IAGX2C,EAAkBpB,GAI1BqB,GAAiB,EACjBP,EAASd,GACTqB,GAAiB,EAGrB,WAA2BC,GACvB,GAAMC,GAAe5B,EAAO6B,EAAmBC,CAE/CF,GAAazC,QAAQ,SAACmC,GAAW,MAAAnD,GAAewD,EAAOL,GACnDxC,iBACI,GAAI4C,EACA,MAAOhB,OAAMjB,UAAU6B,GAAQzC,MAAM8C,EAAOlD,UAEhDiD,IAAiB,CACjB,IAAMK,GAASZ,EAASG,GAAQzC,MAAMsC,EAAU1C,UAEhD,OADAiD,IAAiB,EACVK,MAIf,IAAMC,GAAyBhC,EAAOiC,EAA6BC,CAEnEF,GAAuB7C,QAAQ,SAACmC,GAAW,MAAAnD,GAAewD,EAAOL,GAC7DxC,iBACI4C,GAAiB,CACjB,IAAMK,GAASZ,EAASG,GAAQzC,MAAMsC,EAAU1C,UAEhD,OADAiD,IAAiB,EACVK,OAIX/B,GACA7B,EAAewD,EAAO,QAClB7C,iBACI,GAAI4C,EACA,MAAOhB,OAAMjB,UAAUM,KAAKlB,MAAM8C,EAAOlD,UAG7C,KAAK,GADD0D,GAAO3D,EAAWC,WACb8C,EAAI,EAAGA,EAAIY,EAAKX,SAAUD,EAC/BY,EAAKZ,GAAKjB,EAAqB6B,EAAKZ,GAExCG,IAAiB,CACjB,IAAMK,GAASZ,EAASpB,KAAKlB,MAAMsC,EAAUgB,EAE7C,OADAT,IAAiB,EACVK,KAIf5D,EAAewD,EAAO,WAClB7C,iBACI,GAAI4C,EACA,MAAOhB,OAAMjB,UAAU2C,QAAQvD,MAAM8C,EAAOlD,UAGhD,KAAK,GADD0D,GAAO3D,EAAWC,WACb8C,EAAI,EAAGA,EAAIY,EAAKX,SAAUD,EAC/BY,EAAKZ,GAAKjB,EAAqB6B,EAAKZ,GAExCG,IAAiB,CACjB,IAAMK,GAASZ,EAASiB,QAAQvD,MAAMsC,EAAUgB,EAEhD,OADAT,IAAiB,EACVK,KAIf5D,EAAewD,EAAO,UAClB7C,iBACI,GAAI4C,EACA,MAAOhB,OAAMjB,UAAU4C,OAAOxD,MAAM8C,EAAOlD,UAG/C,IAAIsD,EAGJ,QADAL,GAAiB,EACTjD,UAAU+C,QACd,IAAK,GACL,IAAK,GACL,IAAK,GACDO,EAASZ,EAASkB,OAAOxD,MAAMsC,EAAU1C,UACzC,MAEJ,KAAK,GACDsD,EAASZ,EAASkB,OACd5D,UAAU,GAAIA,UAAU,GAAI6B,EAAqB7B,UAAU,IAE/D,MAEJ,SAEI,IAAK,GADC0D,GAAO3D,EAAWC,WACf8C,EAAI,EAAGA,EAAIY,EAAKX,SAAUD,EAC/BY,EAAKZ,GAAKjB,EAAqB6B,EAAKZ,GAExCQ,GAASZ,EAASkB,OAAOxD,MAAMsC,EAAU1C,WAMjD,MAFAiD,IAAiB,EAEVK,KAIf5D,EAAewD,EAAO,WAClB7C,eAAMwD,EAAcC,GAChBb,GAAiB,CACjB,IAAMK,GAASZ,EAASqB,QAAQF,EAAShC,EAAqBiC,GAE9D,OADAb,IAAiB,EACVK,KAIf5D,EAAewD,EAAO,UAClB7C,eAAM2D,GACF,GAAMC,GAAcvB,EAASC,MAE5BD,GAASwB,kBACVF,EAAQC,EACR,KAAK,GAAInB,GAAI,EAAGA,EAAImB,EAAYlB,SAAUD,EACtCmB,EAAYnB,GAAKjB,EAAqBoC,EAAYnB,GAGrDJ,GAASyB,qBAIlBzE,EAAewD,EAAO,OAClB7C,eAAM+D,EAAeN,GACjB,MAAOpB,GAASkB,OAAOQ,EAAO,EAAGvC,EAAqBiC,IAAU,QAIxEpE,EAAewD,EAAO,UAClB7C,eAAM2D,GAEDtB,EAASwB,kBACVF,EAAQtB,EAASC,QAEhBD,EAASyB,qBAIlBzE,EAAewD,EAAO,OAClB7C,eAAM+D,EAAeN,GACjB,MAAOpB,GAASkB,OAAOQ,EAAO,EAAGN,GAAS,OA9L1D,GAAMpB,GAAWjB,EAAepC,EAAUC,EAAK+E,qBAE3CpB,GAAiB,CAErBvD,GAAeL,EAAUC,GACrBwC,YAAY,EACZC,IAAKW,EACLV,IAAKL,IAGTA,EAAOtB,GCdX,WAA2BW,EAAmB1B,GAC1CI,EAAesB,EAAW1B,GACtByC,eACI,KAAM,IAAIuC,OAAM,yBAA2BhF,EAAIiF,WAAa,0BAEhEvC,aAAkB3B,GACV4B,MAAMC,QAAQ7B,GACdkC,EAAsBiC,KAAMlF,EAAKe,GAAO,GAExCmC,EAAyBgC,KAAMlF,EAAKe,GAAO,MAY3D,WAAyBW,EAAmB1B,GACxCI,EAAesB,EAAW1B,GACtByC,eACI,KAAM,IAAIuC,OAAM,uBAAyBhF,EAAIiF,WAAa,0BAE9DvC,aAAkB3B,GACV4B,MAAMC,QAAQ7B,GACdkC,EAAsBiC,KAAMlF,EAAKe,GAAO,GAExCmC,EAAyBgC,KAAMlF,EAAKe,GAAO,MAe3D,WAAyBW,EAAmB1B,EAAsBmF,GACxD,GAAAC,iBAAE3C,QAAKC,OACb,KAAKD,EACD,KAAM,IAAIuC,OAAM,uBAAyBhF,EAAIiF,WAAa,kBAW9D,OATAE,GAAK1C,IAAM,WACP,GAAM4C,GAAWlD,EAAe+C,KAAMlF,EAAKsF,eAAgB7C,EAAKyC,MAMhE,OALA9E,GAAe8E,KAAMlF,GACjByC,IAAK4C,EAEL3C,IAAKA,IAEF2C,KAEJF,EAQX,WAAgCzD,EAAmB1B,GAC/CI,EAAesB,EAAW1B,GACtByC,eACI,KAAM,IAAIuC,OAAM,8BAAgChF,EAAIiF,WAAa,0BAErEvC,aAAkB3B,GACdkC,EAAsBiC,KAAMlF,EAAKe,GAAO,MAkDpD,WAAuBY,GACnB,MAAO,UAAUD,EAAmB1B,GAChCuF,EAAgB7D,EAAW1B,EAAK2B,IAuDxC,WACI6D,EACAC,EACAC,EACAC,GAkBA,MAhBgB,UAAZA,IACe,SAAXD,EACwB,gBAAbD,IACJA,EAAS5C,cAAgB1C,QACvB,WAAasF,IACb,WAAaA,KAElBE,EAAUF,EACVA,EAAW,QAEU,gBAAXC,KACdC,EAAUD,EACVA,EAAS,SAIV,SAAU7C,GACb+C,aAAcC,SAASL,EAAM3D,GACzBiE,UAAWjD,EAAYY,OAAS,EAAIZ,GAChCkD,yBAAgBC,EAAaZ,MACzBa,aAASC,iBAIT,OAAO,IAAIrD,GAAYmD,EAAQC,EAASC,KAGhDT,SAAUA,GAAY,UACtBU,aAAa,GACdR,KAUX,WAAyBjE,EAAmB1B,EAAsBmF,GACxD,GAAAC,iBAAErE,UAAOb,iBAAcsC,cAC7B,QAEItC,aAAcA,EAEdsC,WAAYA,EACZC,eACI,GAAIyC,OAASxD,EACT,MAAOX,EAEX,IAAMqF,GAAQrF,EAAMsF,KAAKnB,KAIzB,OAHA9E,GAAe8E,KAAMlF,GACjBe,MAAOqF,IAEJA,IAUnB,WAAsB1E,EAAmB1B,GACrCI,EAAesB,EAAW1B,GACtByC,eACI,MAAO6D,GAAoBpB,KAAMlF,MA0D7C,WACIuG,EACA1F,EACA8E,GAEA,GAAMa,GAAOb,GAAWA,EAAQa,OAAQ,CAExC,IAAI5E,EAAe2E,EAAmB,aAAc,CAEhD,GAAME,GAAQF,CAEd,IAAIC,EAAM,CACN,GAAME,GAAeD,EAAM7F,UAAU,WACjC8F,EAAaC,UACb9F,EAASC,MAAM,KAAMJ,YAEzB,OAAOgG,GAEP,MAAOD,GAAM7F,UAAUC,GAI3B,GAGI+F,GAHEC,EAAQlB,GAAWA,EAAQpF,OAAS,SAEtCuG,QAYJ,IARIA,EADAN,EACU,WACNI,EAAaD,UACb9F,EAASC,MAAM,KAAMJ,YAGfG,EAGA,gBAAVgG,EAAyB,CACzB,GAAMzD,GAAWmD,GAEjB,KAAI5D,MAAMC,QAAQQ,KAAaxB,EAAewB,EAAUJ,GAGpD,KAAM,IAAIgC,OAAM,oFAFhB4B,GAAexD,EAASxC,UAAUkG,EAAS,KAAMD,OAIlD,CACH,GAAME,GAAWC,WAAYT,EAE7BK,GAAeG,EAASnG,UAAUkG,EAAS,KAAMD,EAEjD,IAAMI,GAAkBL,EAAaD,OAErCC,GAAaD,QAAU,WACnBM,EAAgBzF,KAAK0D,MACrB6B,EAASJ,WAGjB,MAAOC,GAiBf,WAAuB7G,EAAkBC,GAMrC,MALK4B,GAAe7B,EAAUC,IAG1BD,EAASC,GAENkH,EAAyBnH,EAAUC,GAAKyC,IA0DnD,WAEI0E,GAKA,MAHoB,mBAATA,KACPA,aAAO,cAAQ,yBAGf,iBAAY,aAAAC,mBAAAA,IAAAhD,sCACCA,SAyBjB,MA3BqBiD,QAMjBC,oBAAA,WACI,GAAMC,GAAwCrC,KAAKsC,EAC/CD,IACAA,EAAcnG,QAAQ,SAACqG,GACnBA,EAAad,aAMzBW,sBAAA,WACI,GAAMG,GAAqC7G,EAAUE,MAAM,KAAMJ,WAC3D6G,EAAwCrC,KAAKsC,KAAuBtC,KAAKsC,MAE/E,OADAD,GAAcvF,KAAKyF,GACZA,GAIXH,mBAAA,SAAOtH,GACH,MAAO0H,GAAOxC,KAAMlF,OAzBPmH,GLrdzB,GAEMQ,GAAS,mBAEJ3E,EAA+B2E,EAAS,YACxCzG,EAAiCyG,EAAS,cAC1CH,EAAqCG,EAAS,iBAEnC,oBAAXC,UACP5E,EAAc4E,OAAO5E,GACrB9B,EAAgB0G,OAAO1G,GACvBsG,EAAoBI,OAAOJ,GAQ/B,IAAa3F,GAAegG,QAASpG,OACxBK,EAAgB+F,QAAS/F,cACzBiB,EAAiB5C,OAAO4C,eAAesD,KAAKlG,QAC5C+G,EAA2B/G,OAAO+G,yBAAyBb,KAAKlG,QAChEyB,EAAiBL,SAASG,UAAUF,KAAK6E,KAAKlG,OAAOuB,UAAUE,gBAC/DnB,EAAac,SAASG,UAAUF,KAAK6E,KAAK1D,MAAMjB,UAAUoG,OIjBjEhE,GAAoB,MAAO,UAAW,QAAS,QAC/CC,EAAsBD,UAAkB,OAAQ,SAAU,YAE1DI,GAA8B,SAAU,YAAa,UAAW,aAAc,UAAW,aACzFC,EAAgCD,UAA4B,YAE5DZ,EAAiBS,SAAoBI,GAA2B,SAAU"}