{"version":3,"file":null,"sources":["../src/knockout-decorators.ts"],"sourcesContent":["import * as ko from \"knockout\";\r\n\r\nexport interface ComponentConstructor {\r\n    new (\r\n        params?: any,\r\n        element?: Node,\r\n        templateNodes?: Node[]\r\n    ): any;\r\n}\r\n\r\nexport type ComponentDecorator = (constructor: ComponentConstructor) => void;\r\n\r\nexport type TemplateConfig = (\r\n    string\r\n    | Node[] \r\n    | DocumentFragment \r\n    | { require: string }\r\n    | { element: string | Node }\r\n);\r\n\r\nconst extend = ko.utils.extend;\r\nconst objectForEach = ko.utils.objectForEach;\r\nconst defProp = Object.defineProperty.bind(Object);\r\nconst getDescriptor = Object.getOwnPropertyDescriptor.bind(Object);\r\n\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n    name: string,\r\n    options?: Object\r\n): ComponentDecorator;\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    options?: Object\r\n): ComponentDecorator;\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    styles: string | string[],\r\n    options?: Object\r\n): ComponentDecorator;\r\n\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n * @param name { String } Name of component\r\n * @param template { Any } Knockout template definition\r\n * @param styles { Any } Ignored parameter (used for `require()` styles by webpack etc.)\r\n * @param options { Object } Another options that passed directly to `ko.components.register()`\r\n */\r\nexport function component(\r\n    name: string,\r\n    template?: any,\r\n    styles?: any,\r\n    options?: Object\r\n) {\r\n    if (options === void 0) {\r\n        if (styles === void 0) {\r\n            if (typeof template === \"object\"\r\n                && template.constructor === Object\r\n                && !(\"require\" in template)\r\n                && !(\"element\" in template)\r\n            ) {\r\n                options = template;\r\n                template = void 0;\r\n            }\r\n        } else if (typeof styles === \"object\") {\r\n            options = styles;\r\n            styles = void 0;\r\n        }\r\n    }\r\n\r\n    return function (constructor: ComponentConstructor) {\r\n        ko.components.register(name, extend({\r\n            viewModel: constructor.length < 2 ? constructor : {\r\n                createViewModel(params, { element, templateNodes }) {\r\n                    return new constructor(params, element, templateNodes);\r\n                }\r\n            },\r\n            template: template || \"<!---->\",\r\n            synchronous: true,\r\n        }, options));\r\n    }\r\n}\r\n\r\nconst DECORATORS_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"ko_decorators\") : \"__ko_decorators_\";\r\n\r\nconst SUBSCRIPTIONS_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"ko_decorators_subscriptions\") : \"__ko_decorators_subscriptions_\";\r\n\r\nconst DISPOSABLE_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"ko_decorators_disposable\") : \"__ko_decorators_disposable_\";\r\n\r\nconst enum DecoratorType {\r\n    Extend, Subscribe,\r\n}\r\n\r\ninterface Decorator {\r\n    type: DecoratorType,\r\n    value: any,\r\n    event?: string,\r\n    dispose?: boolean,\r\n}\r\n\r\ninterface MetaData {\r\n    [propName: string]: Decorator[],\r\n}\r\n\r\nexport interface Disposable {\r\n    dispose(): void,\r\n}\r\n\r\nfunction getMetaData(prototype: Object) {\r\n    let metaData: MetaData = prototype[DECORATORS_KEY];\r\n    if (!prototype.hasOwnProperty(DECORATORS_KEY)) {\r\n        prototype[DECORATORS_KEY] = metaData = extend({}, metaData);\r\n        objectForEach(metaData, (key, decorators) => {\r\n            metaData[key] = [...decorators];\r\n        });\r\n    }\r\n    return metaData;\r\n}\r\n\r\nfunction getDecorators(metaData: MetaData, key: string | symbol) {\r\n    return metaData[key] || (metaData[key] = []);\r\n}\r\n\r\nfunction getSubscriptions(instance: Object): Disposable[] {\r\n    return instance[SUBSCRIPTIONS_KEY] || (instance[SUBSCRIPTIONS_KEY] = []);\r\n}\r\n\r\nfunction applyDecorators(\r\n    instance: Object, key: string | symbol,\r\n    target: ko.Observable<any> | ko.PureComputed<any>\r\n) {\r\n    let metaData: MetaData = instance[DECORATORS_KEY];\r\n    let decorators = metaData && metaData[key];\r\n    if (decorators) {\r\n        decorators.forEach(d => {\r\n            switch (d.type) {\r\n                case DecoratorType.Extend:\r\n                    let extender = d.value as Object;\r\n                    target = target.extend(extender);\r\n                    break;\r\n                case DecoratorType.Subscribe:\r\n                    let subscription = target.subscribe(d.value, instance, d.event);\r\n                    if (d.dispose) {\r\n                        getSubscriptions(instance).push(subscription);\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    return target;\r\n}\r\n\r\nfunction redefineDispose(prototype: Object) {\r\n    if (prototype[DISPOSABLE_KEY]) { return; }\r\n    prototype[DISPOSABLE_KEY] = true;\r\n\r\n    let original = prototype[\"dispose\"];\r\n    prototype[\"dispose\"] = function dispose() {\r\n        let disposables = this[SUBSCRIPTIONS_KEY] as Disposable[];\r\n        if (disposables) {\r\n            disposables.forEach(s => { s.dispose(); });\r\n        }\r\n        if (original) {\r\n            return original.apply(this, arguments);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Property decorator that creates hidden ko.observable with ES6 getter and setter for it\r\n */\r\nexport function observable(prototype: Object, key: string | symbol) {\r\n    defProp(prototype, key, {\r\n        get() {\r\n            const observable = applyDecorators(this, key, ko.observable());\r\n            defProp(this, key, { get: observable, set: observable });\r\n            return observable();\r\n        },\r\n        set(value) {\r\n            const observable = applyDecorators(this, key, ko.observable());\r\n            defProp(this, key, { get: observable, set: observable });\r\n            observable(value);\r\n        },\r\n    });\r\n}\r\n\r\n/**\r\n * Accessor decorator that wraps ES6 getter and setter to hidden ko.pureComputed\r\n */\r\nexport function computed(prototype: Object, key: string | symbol) {\r\n    const { get, set } = getDescriptor(prototype, key);\r\n    if (!set) {\r\n        defProp(prototype, key, {\r\n            get() {\r\n                const computed = applyDecorators(this, key, ko.pureComputed(get, this));\r\n                defProp(this, key, { get: computed });\r\n                return computed();\r\n            }\r\n        });\r\n    } else {\r\n        defProp(prototype, key, {\r\n            get() {\r\n                const computed = applyDecorators(this, key,\r\n                    ko.pureComputed({ read: get, write: set, owner: this })\r\n                );\r\n                defProp(this, key, { get: computed, set: computed });\r\n                return computed();\r\n            },\r\n            set(value: any) {\r\n                const computed = applyDecorators(this, key,\r\n                    ko.pureComputed({ read: get, write: set, owner: this })\r\n                );\r\n                defProp(this, key, { get: computed, set: computed });\r\n                computed(value);\r\n            },\r\n        });\r\n    }\r\n}\r\n\r\ntype ObsArray = ko.ObservableArray<any> & { [fnName: string]: Function };\r\n\r\nconst arrayMethods = [\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"];\r\nconst observableArrayMethods = [\"remove\", \"removeAll\", \"destroy\", \"destroyAll\", \"replace\", \"subscribe\"];\r\n\r\nfunction defObservableArray(instance: Object, key: string | symbol) {\r\n    const obsArray = applyDecorators(instance, key, ko.observableArray()) as ObsArray;\r\n    \r\n    let insideObsArray = false;\r\n    defProp(instance, key, {\r\n        get: obsArray,\r\n        set(array: any[]) {\r\n            if (array) {\r\n                arrayMethods.forEach(fnName => defProp(array, fnName, {\r\n                    enumerable: false,\r\n                    value: function () {\r\n                        if (insideObsArray) {\r\n                            return Array.prototype[fnName].apply(array, arguments);\r\n                        }\r\n                        insideObsArray = true;\r\n                        const result = obsArray[fnName].apply(obsArray, arguments);\r\n                        insideObsArray = false;\r\n                        return result;\r\n                    }\r\n                }));\r\n                observableArrayMethods.forEach(fnName => defProp(array, fnName, {\r\n                    enumerable: false,\r\n                    value: function () {\r\n                        insideObsArray = true;\r\n                        const result = obsArray[fnName].apply(obsArray, arguments);\r\n                        insideObsArray = false;\r\n                        return result;\r\n                    }\r\n                }));\r\n            }\r\n            insideObsArray = true;\r\n            obsArray(array);\r\n            insideObsArray = false;\r\n        }\r\n    });\r\n}\r\n\r\nexport interface ObservableArray<T> extends Array<T> {\r\n    replace(oldItem: T, newItem: T): void;\r\n\r\n    remove(item: T): T[];\r\n    remove(removeFunction: (item: T) => boolean): T[];\r\n    \r\n    removeAll(): T[];\r\n    removeAll(items: T[]): T[];\r\n\r\n    destroy(item: T): void;\r\n    destroy(destroyFunction: (item: T) => boolean): void;\r\n    \r\n    destroyAll(): void;\r\n    destroyAll(items: T[]): void;\r\n\r\n    subscribe(callback: (val: T[]) => void): Disposable;\r\n    subscribe(callback: (val: T[]) => void, callbackTarget: any): Disposable;\r\n    subscribe(callback: (val: T[]) => void, callbackTarget: any, event: string): Disposable;\r\n}\r\n\r\n/**\r\n * Property decorator that creates hidden ko.observableArray with ES6 getter and setter for it\r\n */\r\nexport function observableArray(prototype: Object, key: string | symbol) {\r\n    defProp(prototype, key, {\r\n        get() {\r\n            defObservableArray(this, key);\r\n            return this[key];\r\n        },\r\n        set(value: any[]) {\r\n            defObservableArray(this, key);\r\n            return this[key] = value;\r\n        },\r\n    });\r\n}\r\n\r\n/**\r\n * Replace original method with factory that produces ko.computed from original method\r\n */\r\nexport function observer(autoDispose: boolean): MethodDecorator;\r\nexport function observer(prototype: Object, key: string | symbol): void;\r\n\r\n/**\r\n * Replace original method with factory that produces ko.computed from original method\r\n * @param autoDispose { Boolean } if true then subscription will be disposed when entire ViewModel is disposed\r\n */\r\nexport function observer(prototypeOrAutoDispose: Object | boolean, key?: string | symbol) {\r\n    let autoDispose: boolean;\r\n    if (typeof prototypeOrAutoDispose === \"boolean\" && key === void 0) {\r\n        autoDispose = prototypeOrAutoDispose;       // @observer(false)\r\n        return decorator;                           // onSomethingChange() {}\r\n    } else if (typeof prototypeOrAutoDispose === \"object\" && key !== void 0) {\r\n        autoDispose = true;                         // @observer\r\n        decorator(prototypeOrAutoDispose, key);     // onSomethingChange() {}\r\n    } else {\r\n        throw new Error(\"Can not use @observer decorator this way\");\r\n    }\r\n\r\n    function decorator(prototype: Object, key: string | symbol) {\r\n        let original = prototype[key] as Function;\r\n        prototype[key] = function (...args) {\r\n            let computed = ko.computed(() => original.apply(this, args));\r\n            if (autoDispose) {\r\n                getSubscriptions(this).push(computed);\r\n            }\r\n            return computed;\r\n        }\r\n        if (autoDispose) {\r\n            redefineDispose(prototype);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Subscribe to observable or computed by name or by specifying callback explicitely\r\n */\r\nexport function subscribe(callback: (value: any) => void, event?: string, autoDispose?: boolean): PropertyDecorator;\r\nexport function subscribe(targetOrCallback: string | symbol, event?: string, autoDispose?: boolean): PropertyDecorator;\r\nexport function subscribe(targetOrCallback: string | symbol, event?: string, autoDispose?: boolean): MethodDecorator;\r\n\r\n/**\r\n * Subscribe to observable or computed by name or by specifying callback explicitely\r\n * @param targetOrCallback { String | Function } name of callback or callback itself\r\n * when observable is decorated and name of observable property when callback is decorated\r\n * @param event { String } Knockout subscription event name\r\n * @param autoDispose { Boolean } if true then subscription will be disposed when entire ViewModel is disposed\r\n */\r\nexport function subscribe(targetOrCallback: string | symbol | Function, event?: string, autoDispose = true) {\r\n    return function (prototype: Object, key: string | symbol) {\r\n        let { value, get } = getDescriptor(prototype, key);\r\n        let target: string | symbol, callback: Function;\r\n        if (typeof value === \"function\") {\r\n            if (typeof targetOrCallback === \"string\" || typeof targetOrCallback === \"symbol\") {\r\n                target = targetOrCallback;                      // @subscribe(\"target\")\r\n                callback = value;                               // callback(value) {}    \r\n            } else {\r\n                throw new Error(\"Subscription target should be a key in decorated ViewModel\");\r\n            }\r\n        } else if (typeof get === \"function\") {\r\n            if (typeof targetOrCallback === \"function\") {\r\n                target = key;                                   // @subscribe(ViewModel.prototype.callback)\r\n                callback = targetOrCallback;                    // @observable target;\r\n            } else if (typeof targetOrCallback === \"string\" || typeof targetOrCallback === \"symbol\") {\r\n                target = key;                                   // @subscribe(\"callback\")\r\n                callback = prototype[targetOrCallback];         // @observable target;\r\n            } else {\r\n                throw new Error(\"Subscription callback should be a function or key in decorated ViewModel\");\r\n            }\r\n        }\r\n        getDecorators(getMetaData(prototype), target).push({\r\n            type: DecoratorType.Subscribe,\r\n            value: callback,\r\n            event: event,\r\n            dispose: autoDispose,\r\n        });\r\n        if (autoDispose) {\r\n            redefineDispose(prototype);\r\n        }\r\n    }\r\n}"],"names":["name","template","styles","options","constructor","Object","ko","components","register","extend","viewModel","length","createViewModel","params","_a","element","templateNodes","synchronous","prototype","metaData","DECORATORS_KEY","hasOwnProperty","objectForEach","key","decorators","instance","SUBSCRIPTIONS_KEY","target","forEach","d","type","DecoratorType","Extend","extender","value","Subscribe","subscription","subscribe","event","dispose","getSubscriptions","push","DISPOSABLE_KEY","original","disposables","this","s","apply","arguments","defProp","get","observable","applyDecorators","set","computed","pureComputed","read","write","owner","obsArray","observableArray","insideObsArray","array","arrayMethods","fnName","enumerable","Array","result","observableArrayMethods","defObservableArray","prototypeOrAutoDispose","_i","args","_this","autoDispose","redefineDispose","decorator","Error","targetOrCallback","callback","getDecorators","getMetaData","utils","defineProperty","bind","getDescriptor","getOwnPropertyDescriptor","Symbol"],"mappings":"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"}