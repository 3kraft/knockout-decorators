{"version":3,"file":null,"sources":["../src/knockout-decorators.ts"],"sourcesContent":["/**\r\n * Copyright (c) 2016 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\n\r\nexport interface ComponentConstructor {\r\n    new (\r\n        params?: any,\r\n        element?: Node,\r\n        templateNodes?: Node[]\r\n    ): any;\r\n}\r\n\r\nexport type ComponentDecorator = (constructor: ComponentConstructor) => void;\r\n\r\nexport type TemplateConfig = (\r\n    string\r\n    | Node[] \r\n    | DocumentFragment \r\n    | { require: string }\r\n    | { element: string | Node }\r\n);\r\n\r\nconst assign = ko.utils.extend;\r\nconst objectForEach = ko.utils.objectForEach;\r\nconst defProp = Object.defineProperty.bind(Object);\r\nconst getDescriptor = Object.getOwnPropertyDescriptor.bind(Object);\r\nconst hasOwnProperty = Function.prototype.call.bind(Object.prototype.hasOwnProperty);\r\nconst slice = Function.prototype.call.bind(Array.prototype.slice);\r\n\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n    name: string,\r\n    options?: Object\r\n): ComponentDecorator;\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    options?: Object\r\n): ComponentDecorator;\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    styles: string | string[],\r\n    options?: Object\r\n): ComponentDecorator;\r\n\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n * @param name { String } Name of component\r\n * @param template { Any } Knockout template definition\r\n * @param styles { Any } Ignored parameter (used for `require()` styles by webpack etc.)\r\n * @param options { Object } Another options that passed directly to `ko.components.register()`\r\n */\r\nexport function component(\r\n    name: string,\r\n    template?: any,\r\n    styles?: any,\r\n    options?: Object\r\n) {\r\n    if (options === void 0) {\r\n        if (styles === void 0) {\r\n            if (typeof template === \"object\"\r\n                && template.constructor === Object\r\n                && !(\"require\" in template)\r\n                && !(\"element\" in template)\r\n            ) {\r\n                options = template;\r\n                template = void 0;\r\n            }\r\n        } else if (typeof styles === \"object\") {\r\n            options = styles;\r\n            styles = void 0;\r\n        }\r\n    }\r\n\r\n    return function (constructor: ComponentConstructor) {\r\n        ko.components.register(name, assign({\r\n            viewModel: constructor.length < 2 ? constructor : {\r\n                createViewModel(params, { element, templateNodes }) {\r\n                    return new constructor(params, element, templateNodes);\r\n                }\r\n            },\r\n            template: template || \"<!---->\",\r\n            synchronous: true,\r\n        }, options));\r\n    }\r\n}\r\n\r\nconst DECORATORS_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"ko_decorators\") : \"__ko_decorators_\";\r\n\r\nconst SUBSCRIPTIONS_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"ko_decorators_subscriptions\") : \"__ko_decorators_subscriptions_\";\r\n\r\nconst DISPOSABLE_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"ko_decorators_disposable\") : \"__ko_decorators_disposable_\";\r\n\r\nexport interface Disposable {\r\n    dispose(): void,\r\n}\r\n\r\nconst enum DecoratorType {\r\n    Extend, Subscribe,\r\n}\r\n\r\ninterface Decorator {\r\n    type: DecoratorType,\r\n    value: any,\r\n    event?: string,\r\n    dispose?: boolean,\r\n}\r\n\r\ninterface DecoratorsMetaData {\r\n    [propName: string]: Decorator[],\r\n}\r\n\r\nfunction getMetaData(prototype: Object) {\r\n    let metaData: DecoratorsMetaData = prototype[DECORATORS_KEY];\r\n    if (!prototype.hasOwnProperty(DECORATORS_KEY)) {\r\n        prototype[DECORATORS_KEY] = metaData = assign({}, metaData) as DecoratorsMetaData;\r\n        objectForEach(metaData, (key, decorators) => {\r\n            metaData[key] = [...decorators];\r\n        });\r\n    }\r\n    return metaData;\r\n}\r\n\r\nfunction getDecorators(metaData: DecoratorsMetaData, key: string | symbol) {\r\n    return metaData[key] || (metaData[key] = []);\r\n}\r\n\r\nfunction getSubscriptions(instance: Object): Disposable[] {\r\n    return instance[SUBSCRIPTIONS_KEY] || (instance[SUBSCRIPTIONS_KEY] = []);\r\n}\r\n\r\nfunction applyDecorators(\r\n    instance: Object, key: string | symbol,\r\n    target: KnockoutObservable<any> | KnockoutComputed<any>\r\n) {\r\n    const metaData: DecoratorsMetaData = instance[DECORATORS_KEY];\r\n    const decorators = metaData && metaData[key];\r\n    if (decorators) {\r\n        decorators.forEach(d => {\r\n            switch (d.type) {\r\n                case DecoratorType.Extend:\r\n                    const extenders = d.value instanceof Function\r\n                        ? d.value.call(instance) : d.value;\r\n                    target = target.extend(extenders);\r\n                    break;\r\n                case DecoratorType.Subscribe:\r\n                    const subscription = target.subscribe(d.value, instance, d.event);\r\n                    if (d.dispose) {\r\n                        getSubscriptions(instance).push(subscription);\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    return target;\r\n}\r\n\r\nfunction redefineDispose(prototype: Object) {\r\n    if (prototype[DISPOSABLE_KEY]) { return; }\r\n    prototype[DISPOSABLE_KEY] = true;\r\n\r\n    const original = prototype[\"dispose\"];\r\n    prototype[\"dispose\"] = function dispose() {\r\n        const disposables = this[SUBSCRIPTIONS_KEY] as Disposable[];\r\n        if (disposables) {\r\n            disposables.forEach(s => { s.dispose(); });\r\n        }\r\n        if (original) {\r\n            return original.apply(this, arguments);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Property decorator that creates hidden ko.observable with ES6 getter and setter for it\r\n */\r\nexport function observable(prototype: Object, key: string | symbol) {\r\n    defProp(prototype, key, {\r\n        configurable: true,\r\n        get() {\r\n            const observable = applyDecorators(this, key, ko.observable());\r\n            defProp(this, key, {\r\n                configurable: true,\r\n                enumerable: true,\r\n                get: observable,\r\n                set: observable,\r\n            });\r\n            return observable();\r\n        },\r\n        set(value) {\r\n            const observable = applyDecorators(this, key, ko.observable());\r\n            defProp(this, key, {\r\n                configurable: true,\r\n                enumerable: true,\r\n                get: observable,\r\n                set: observable,\r\n            });\r\n            observable(value);\r\n        },\r\n    });\r\n}\r\n\r\ntype ObsArray = KnockoutObservableArray<any> & { [fnName: string]: Function };\r\n\r\nconst arrayMethods = [\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"];\r\nconst observableArrayMethods = [\"remove\", \"removeAll\", \"destroy\", \"destroyAll\", \"replace\", \"subscribe\"];\r\n\r\nfunction defObservableArray(instance: Object, key: string | symbol) {\r\n    const obsArray = applyDecorators(instance, key, ko.observableArray()) as ObsArray;\r\n    \r\n    let insideObsArray = false;\r\n\r\n    defProp(instance, key, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get: obsArray,\r\n        set(value: any[]) {\r\n            const lastValue = obsArray.peek();\r\n            // if we got new value\r\n            if (lastValue !== value) {\r\n                if (Array.isArray(lastValue)) {\r\n                    // if lastValue array methods were already patched\r\n                    if (hasOwnProperty(lastValue, \"subscribe\")) {\r\n                        // clear patched array methods on lastValue (see unit tests)\r\n                        clearArrayMethods(lastValue);\r\n                    }\r\n                }\r\n                if (Array.isArray(value)) {\r\n                    // if new value array methods were already connected with another @observableArray\r\n                    if (hasOwnProperty(value, \"subscribe\")) {\r\n                        // clone new value to prevent corruption of another @observableArray (see unit tests)\r\n                        value = slice(value);\r\n                    }\r\n                    // call ko.observableArray.fn[fnName] instead of Array.prototype[fnName]\r\n                    patchArrayMethods(value);\r\n                }\r\n            }\r\n            insideObsArray = true;\r\n            obsArray(value);\r\n            insideObsArray = false;\r\n        }\r\n    });\r\n\r\n    function patchArrayMethods(array: any[]) {\r\n        arrayMethods.forEach(fnName => defProp(array, fnName, {\r\n            configurable: true,\r\n            value() {\r\n                if (insideObsArray) {\r\n                    return Array.prototype[fnName].apply(array, arguments);\r\n                }\r\n                insideObsArray = true;\r\n                const result = obsArray[fnName].apply(obsArray, arguments);\r\n                insideObsArray = false;\r\n                return result;\r\n            }\r\n        }));\r\n        observableArrayMethods.forEach(fnName => defProp(array, fnName, {\r\n            configurable: true,\r\n            value() {\r\n                insideObsArray = true;\r\n                const result = obsArray[fnName].apply(obsArray, arguments);\r\n                insideObsArray = false;\r\n                return result;\r\n            }\r\n        }));\r\n    }\r\n\r\n    function clearArrayMethods(array: any[]) {\r\n        arrayMethods.forEach(fnName => {\r\n            delete array[fnName]; \r\n        });\r\n        observableArrayMethods.forEach(fnName => {\r\n            delete array[fnName]; \r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Property decorator that creates hidden ko.observableArray with ES6 getter and setter for it\r\n */\r\nexport function observableArray(prototype: Object, key: string | symbol) {\r\n    defProp(prototype, key, {\r\n        configurable: true,\r\n        get() {\r\n            defObservableArray(this, key);\r\n            this[key] = [];\r\n            return this[key];\r\n        },\r\n        set(value: any[]) {\r\n            defObservableArray(this, key);\r\n            this[key] = value;\r\n        },\r\n    });\r\n}\r\n\r\nexport interface ObservableArray<T> extends Array<T> {\r\n    replace(oldItem: T, newItem: T): void;\r\n\r\n    remove(item: T): T[];\r\n    remove(removeFunction: (item: T) => boolean): T[];\r\n    \r\n    removeAll(): T[];\r\n    removeAll(items: T[]): T[];\r\n\r\n    destroy(item: T): void;\r\n    destroy(destroyFunction: (item: T) => boolean): void;\r\n    \r\n    destroyAll(): void;\r\n    destroyAll(items: T[]): void;\r\n\r\n    subscribe(callback: (val: T[]) => void): Disposable;\r\n    subscribe(callback: (val: T[]) => void, callbackTarget: any): Disposable;\r\n    subscribe(callback: (val: any[]) => void, callbackTarget: any, event: string): Disposable;\r\n}\r\n\r\n/**\r\n * Accessor decorator that wraps ES6 getter and setter to hidden ko.pureComputed\r\n */\r\nexport function computed(prototype: Object, key: string | symbol, desc: PropertyDescriptor) {\r\n    const { get, set } = desc || (desc = getDescriptor(prototype, key));\r\n    desc.get = function () {\r\n        const computed = ko.pureComputed(get, this);\r\n        defProp(this, key, {\r\n            configurable: true,\r\n            get: computed,\r\n            set: set\r\n        });\r\n        return computed();\r\n    };\r\n    return desc;\r\n    // TODO: make @computed extendable (by @extend decorator)\r\n}\r\n\r\n/**\r\n * Replace original method with factory that produces ko.computed from original method\r\n */\r\nexport function reaction(autoDispose: boolean): MethodDecorator;\r\nexport function reaction(prototype: Object, key: string | symbol, desc: PropertyDescriptor): PropertyDescriptor;\r\n\r\n/**\r\n * Replace original method with factory that produces ko.computed from original method\r\n * @param autoDispose { Boolean } if true then subscription will be disposed when entire ViewModel is disposed\r\n */\r\nexport function reaction(\r\n    prototypeOrAutoDispose: Object | boolean, key?: string | symbol, desc?: PropertyDescriptor\r\n) {\r\n    let autoDispose: boolean;\r\n    if (typeof prototypeOrAutoDispose === \"boolean\" && key === void 0) {\r\n        autoDispose = prototypeOrAutoDispose;         // @reaction(false)\r\n        return decorator;                             // onSomethingChange() {}\r\n    } else if (typeof prototypeOrAutoDispose === \"object\" && key !== void 0) {\r\n        autoDispose = true;                           // @reaction\r\n        decorator(prototypeOrAutoDispose, key, desc); // onSomethingChange() {}\r\n    } else {\r\n        throw new Error(\"Can not use @reaction decorator this way\");\r\n    }\r\n\r\n    function decorator(prototype: Object, key: string | symbol, desc: PropertyDescriptor) {\r\n        const { value } = desc || (desc = getDescriptor(prototype, key));\r\n        desc.value = function () {\r\n            const args = slice(arguments);\r\n            const computed = ko.computed(() => value.apply(this, args));\r\n            if (autoDispose) {\r\n                getSubscriptions(this).push(computed);\r\n            }\r\n            return computed;\r\n        };\r\n        if (autoDispose) {\r\n            redefineDispose(prototype);\r\n        }\r\n        return desc;\r\n    }\r\n}\r\n\r\n/**\r\n * Apply extenders to decorated @observable\r\n */\r\nexport function extend(extenders: Object): PropertyDecorator;\r\nexport function extend(extendersFactory: () => Object): PropertyDecorator;\r\n\r\n/**\r\n * Apply extenders to decorated @observable\r\n * @extendersOrFactory { Object | Function } Knockout extenders definition or factory that produces definition\r\n */\r\nexport function extend(extendersOrFactory: Object | Function) {\r\n    return function (prototype: Object, key: string | symbol) {\r\n        getDecorators(getMetaData(prototype), key).push({\r\n            type: DecoratorType.Extend,\r\n            value: extendersOrFactory,\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Subscribe to @observable by name or by specifying callback explicitely\r\n */\r\nexport function subscribe(callback: (value: any) => void, event?: string, autoDispose?: boolean): PropertyDecorator;\r\nexport function subscribe(targetOrCallback: string | symbol, event?: string, autoDispose?: boolean): PropertyDecorator;\r\nexport function subscribe(targetOrCallback: string | symbol, event?: string, autoDispose?: boolean): MethodDecorator;\r\n\r\n/**\r\n * Shorthand for ko.pureComputed(dependency).subscribe(callback)\r\n */\r\nexport function subscribe<T>(dependency: () => T, callback: (value: T) => void): KnockoutSubscription;\r\n\r\n/**\r\n * Subscribe to @observable by name or by specifying callback explicitely\r\n * @param targetOrCallback { String | Function } name of callback or callback itself\r\n * when observable is decorated and name of observable property when callback is decorated\r\n * @param event { String } Knockout subscription event name\r\n * @param autoDispose { Boolean } if true then subscription will be disposed when entire ViewModel is disposed\r\n */\r\nexport function subscribe(\r\n    targetOrCallback: string | symbol | Function, event?: string | Function, autoDispose = true\r\n) {\r\n    if (typeof event === \"function\") {\r\n        // subscribe(() => this.observableField, (value) => { ... });\r\n        return ko.pureComputed(targetOrCallback as any).subscribe(event as any);\r\n    }\r\n    return function (prototype: Object, key: string | symbol, desc: PropertyDescriptor) {\r\n        const { value, get } = desc || (desc = getDescriptor(prototype, key));\r\n        let targetKey: string | symbol;\r\n        let callback: Function;\r\n        if (typeof value === \"function\") {\r\n            if (typeof targetOrCallback === \"string\" || typeof targetOrCallback === \"symbol\") {\r\n                targetKey = targetOrCallback;                   // @subscribe(\"target\")\r\n                callback = value;                               // callback(value) {}    \r\n            } else {\r\n                throw new Error(\"Subscription target should be a key in decorated ViewModel\");\r\n            }\r\n        } else if (typeof get === \"function\") {\r\n            if (typeof targetOrCallback === \"function\") {\r\n                targetKey = key;                                // @subscribe(ViewModel.prototype.callback)\r\n                callback = targetOrCallback;                    // @observable target;\r\n            } else if (typeof targetOrCallback === \"string\" || typeof targetOrCallback === \"symbol\") {\r\n                targetKey = key;                                // @subscribe(\"callback\")\r\n                callback = prototype[targetOrCallback];         // @observable target;\r\n            } else {\r\n                throw new Error(\"Subscription callback should be a function or key in decorated ViewModel\");\r\n            }\r\n        }\r\n        getDecorators(getMetaData(prototype), targetKey).push({\r\n            type: DecoratorType.Subscribe,\r\n            value: callback,\r\n            event: event,\r\n            dispose: autoDispose,\r\n        });\r\n        if (autoDispose) {\r\n            redefineDispose(prototype);\r\n        }\r\n        return desc as any;\r\n    }\r\n}\r\n\r\n/**\r\n * Like https://github.com/jayphelps/core-decorators.js @autobind but less smart and complex\r\n * Do NOT use with ES6 inheritance!\r\n */\r\nexport function autobind(prototype: Object, key: string | symbol, desc: PropertyDescriptor) {\r\n    const { value, configurable, enumerable } = desc || (desc = getDescriptor(prototype, key));\r\n    return {\r\n        configurable: configurable,\r\n        enumerable: enumerable,\r\n        get() {\r\n            if (this === prototype) {\r\n                return value;\r\n            }\r\n            const bound = value.bind(this);\r\n            defProp(this, key, {\r\n                configurable: true,\r\n                value: bound,\r\n            });\r\n            return bound;\r\n        }\r\n    } as PropertyDescriptor;\r\n}\r\n\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap(instance: Object, key: string | symbol): any;\r\nexport function unwrap<T>(instance: Object, key: string | symbol): KnockoutObservable<T>;\r\nexport function unwrap(instance: Object, key: string | symbol) {\r\n    return getDescriptor(instance, key).get;\r\n}"],"names":["name","template","styles","options","constructor","Object","ko.components","register","assign","viewModel","length","createViewModel","params","_a","element","templateNodes","synchronous","prototype","metaData","DECORATORS_KEY","hasOwnProperty","objectForEach","key","decorators","instance","SUBSCRIPTIONS_KEY","target","forEach","d","type","DecoratorType","Extend","extenders","value","Function","call","extend","Subscribe","subscription","subscribe","event","dispose","getSubscriptions","push","DISPOSABLE_KEY","original","disposables","this","s","apply","arguments","defProp","configurable","get","observable","applyDecorators","ko.observable","enumerable","set","array","arrayMethods","fnName","insideObsArray","Array","result","obsArray","observableArrayMethods","ko.observableArray","lastValue","peek","isArray","clearArrayMethods","slice","patchArrayMethods","defObservableArray","desc","computed","ko.pureComputed","prototypeOrAutoDispose","args","ko.computed","_this","autoDispose","redefineDispose","decorator","Error","extendersOrFactory","getDecorators","getMetaData","targetOrCallback","targetKey","callback","bound","bind","getDescriptor","ko.utils","defineProperty","getOwnPropertyDescriptor","Symbol"],"mappings":"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"}