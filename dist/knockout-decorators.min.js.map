{"version":3,"file":null,"sources":["../src/property-extenders.ts","../src/observable-array.ts","../src/observable-property.ts","../src/event-property.ts","../src/knockout-decorators.ts","../src/common-functions.ts"],"sourcesContent":["/**\r\n * Copyright (c) 2016-2017 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\nimport { hasOwnProperty, extendObject, objectForEach } from \"./common-functions\";\r\n\r\nconst EXTENDERS_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"ko_decorators_extenders\") : \"__ko_decorators_extenders__\";\r\n\r\ntype Extender = Object | Function;\r\n\r\ninterface ExtendersDictionary {\r\n    [propName: string]: Extender[];\r\n}\r\n\r\nexport function applyExtenders(\r\n    instance: Object, key: string | symbol,\r\n    target: KnockoutObservable<any> | KnockoutComputed<any>\r\n) {\r\n    const dictionary = instance[EXTENDERS_KEY] as ExtendersDictionary;\r\n    const extenders = dictionary && dictionary[key];\r\n    if (extenders) {\r\n        extenders.forEach(extender => {\r\n            const koExtender = extender instanceof Function\r\n                ? extender.call(instance) : extender;\r\n\r\n            target = target.extend(koExtender);\r\n        });\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function defineExtenders(\r\n    prototype: Object, key: string | symbol,\r\n    extendersOrFactory: Object | Function\r\n) {\r\n    let dictionary = prototype[EXTENDERS_KEY] as ExtendersDictionary;\r\n    // if there is no ExtendersDictionary or ExtendersDictionary lives in base class prototype\r\n    if (!hasOwnProperty(prototype, EXTENDERS_KEY)) {\r\n        // clone ExtendersDictionary from base class prototype or create new ExtendersDictionary\r\n        prototype[EXTENDERS_KEY] = dictionary = extendObject({}, dictionary) as ExtendersDictionary;\r\n        // clone Extenders arrays for each property key\r\n        objectForEach(dictionary, (key, extenders) => {\r\n            dictionary[key] = [...extenders];\r\n        });\r\n    }\r\n    // get existing Extenders array or create new array\r\n    const extenders = dictionary[key] || (dictionary[key] = []);\r\n    // add new Extenders\r\n    extenders.push(extendersOrFactory);\r\n}","/**\r\n * Copyright (c) 2016-2017 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\nimport { defineProperty, hasOwnProperty, arraySlice } from \"./common-functions\";\r\nimport { applyExtenders } from \"./property-extenders\";\r\nimport { prepareReactiveValue } from \"./observable-property\";\r\n\r\ntype ObsArray = KnockoutObservableArray<any> & { [fnName: string]: Function };\r\n\r\nconst deepArrayMethods = [\"pop\", \"reverse\", \"shift\", \"sort\"];\r\nconst allArrayMethods = [...deepArrayMethods, \"push\", \"splice\", \"unshift\"];\r\n\r\nconst deepObservableArrayMethods = [\"remove\", \"removeAll\", \"destroy\", \"destroyAll\", \"replace\", \"subscribe\"];\r\nconst allObservableArrayMethods = [...deepObservableArrayMethods, \"replace\"];\r\n\r\nconst allMethods = [...allArrayMethods, ...allObservableArrayMethods, \"mutate\", \"set\"];\r\n\r\nexport function defineObservableArray(\r\n    instance: Object, key: string | symbol, value: any[], deep: boolean\r\n) {\r\n    const obsArray = applyExtenders(instance, key, ko.observableArray()) as ObsArray;\r\n    \r\n    let insideObsArray = false;\r\n\r\n    defineProperty(instance, key, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get: obsArray,\r\n        set: setter, \r\n    });\r\n\r\n    setter(value);\r\n\r\n    function setter(newValue: any[]) {\r\n        const lastValue = obsArray.peek();\r\n        // if we got new value\r\n        if (lastValue !== newValue) {\r\n            if (Array.isArray(lastValue)) {\r\n                // if lastValue array methods were already patched\r\n                if (hasOwnProperty(lastValue, \"mutate\")) {\r\n                    // clear patched array methods on lastValue (see unit tests)\r\n                    allMethods.forEach(fnName => {\r\n                        delete lastValue[fnName];\r\n                    });\r\n                }\r\n            }\r\n            if (Array.isArray(newValue)) {\r\n                // if new value array methods were already connected with another @observable\r\n                if (hasOwnProperty(newValue, \"mutate\")) {\r\n                    // clone new value to prevent corruption of another @observable (see unit tests)\r\n                    newValue = [...newValue];\r\n                }\r\n                // if deep option is set\r\n                if (deep) {\r\n                    // make all array items reactive\r\n                    for (let i = 0; i < newValue.length; ++i) {\r\n                        newValue[i] = prepareReactiveValue(newValue[i]);\r\n                    }\r\n                }\r\n                // call ko.observableArray.fn[fnName] instead of Array.prototype[fnName]\r\n                patchArrayMethods(newValue);\r\n            }\r\n        }\r\n        // update obsArray contents\r\n        insideObsArray = true;\r\n        obsArray(newValue);\r\n        insideObsArray = false;\r\n    }\r\n\r\n    function patchArrayMethods(array: any[]) {\r\n        const arrayMethods = deep ? deepArrayMethods : allArrayMethods;\r\n\r\n        arrayMethods.forEach(fnName => defineProperty(array, fnName, {\r\n            configurable: true,\r\n            value() {\r\n                if (insideObsArray) {\r\n                    return Array.prototype[fnName].apply(array, arguments);\r\n                }\r\n                insideObsArray = true;\r\n                const result = obsArray[fnName].apply(obsArray, arguments);\r\n                insideObsArray = false;\r\n                return result;\r\n            }\r\n        }));\r\n        \r\n        const observableArrayMethods = deep ? deepObservableArrayMethods : allObservableArrayMethods;\r\n\r\n        observableArrayMethods.forEach(fnName => defineProperty(array, fnName, {\r\n            configurable: true,\r\n            value() {\r\n                insideObsArray = true;\r\n                const result = obsArray[fnName].apply(obsArray, arguments);\r\n                insideObsArray = false;\r\n                return result;\r\n            }\r\n        }));\r\n\r\n        if (deep) {\r\n            defineProperty(array, \"push\", {\r\n                configurable: true,\r\n                value() {\r\n                    if (insideObsArray) {\r\n                        return Array.prototype.push.apply(array, arguments);\r\n                    }\r\n                    let args = arraySlice(arguments);\r\n                    for (let i = 0; i < args.length; ++i) {\r\n                        args[i] = prepareReactiveValue(args[i]);\r\n                    }\r\n                    insideObsArray = true;\r\n                    const result = obsArray.push.apply(obsArray, args);\r\n                    insideObsArray = false;\r\n                    return result;\r\n                }\r\n            });\r\n\r\n            defineProperty(array, \"unshift\", {\r\n                configurable: true,\r\n                value() {\r\n                    if (insideObsArray) {\r\n                        return Array.prototype.unshift.apply(array, arguments);\r\n                    }\r\n                    let args = arraySlice(arguments);\r\n                    for (let i = 0; i < args.length; ++i) {\r\n                        args[i] = prepareReactiveValue(args[i]);\r\n                    }\r\n                    insideObsArray = true;\r\n                    const result = obsArray.unshift.apply(obsArray, args);\r\n                    insideObsArray = false;\r\n                    return result;\r\n                }\r\n            });\r\n\r\n            defineProperty(array, \"splice\", {\r\n                configurable: true,\r\n                value() {\r\n                    if (insideObsArray) {\r\n                        return Array.prototype.splice.apply(array, arguments);\r\n                    }\r\n\r\n                    let result: any[];\r\n                    \r\n                    insideObsArray = true;\r\n                    switch (arguments.length) {\r\n                        case 0:\r\n                        case 1:\r\n                        case 2: {\r\n                            result = obsArray.splice.apply(obsArray, arguments);\r\n                            break;\r\n                        }\r\n                        case 3: {\r\n                            result = obsArray.splice(\r\n                                arguments[0], arguments[1], prepareReactiveValue(arguments[2])\r\n                            );\r\n                            break;\r\n                        }\r\n                        default: {\r\n                            const args = arraySlice(arguments);\r\n                            for (let i = 2; i < args.length; ++i) {\r\n                                args[i] = prepareReactiveValue(args[i]);\r\n                            }\r\n                            result = obsArray.splice.apply(obsArray, arguments);\r\n                            break;\r\n                        }\r\n                    }\r\n                    insideObsArray = false;\r\n\r\n                    return result;\r\n                }\r\n            });\r\n\r\n            defineProperty(array, \"replace\", {\r\n                configurable: true,\r\n                value(oldItem: any, newItem: any) {\r\n                    insideObsArray = true;\r\n                    const result = obsArray.replace(oldItem, prepareReactiveValue(newItem));\r\n                    insideObsArray = false;\r\n                    return result;\r\n                }\r\n            });\r\n\r\n            defineProperty(array, \"mutate\", {\r\n                configurable: true,\r\n                value(mutator: (array?: any[]) => void) {\r\n                    const array = obsArray.peek();\r\n                    obsArray.valueWillMutate();\r\n                    mutator(array);\r\n                    for (let i = 0; i < array.length; ++i) {\r\n                        array[i] = prepareReactiveValue(array[i]);\r\n                    }\r\n                    obsArray.valueHasMutated();\r\n                }\r\n            });\r\n\r\n            defineProperty(array, \"set\", {\r\n                configurable: true,\r\n                value(index: number, newItem: any) {\r\n                    return obsArray.splice(index, 1, prepareReactiveValue(newItem))[0];\r\n                }\r\n            });\r\n        } else {\r\n            defineProperty(array, \"mutate\", {\r\n                configurable: true,\r\n                value(mutator: (array?: any[]) => void) {\r\n                    obsArray.valueWillMutate();\r\n                    mutator(obsArray.peek());\r\n                    obsArray.valueHasMutated();\r\n                }\r\n            });\r\n\r\n            defineProperty(array, \"set\", {\r\n                configurable: true,\r\n                value(index: number, newItem: any) {\r\n                    return obsArray.splice(index, 1, newItem)[0];\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport interface ObservableArray<T> extends Array<T> {\r\n    replace(oldItem: T, newItem: T): void;\r\n\r\n    remove(item: T): T[];\r\n    remove(removeFunction: (item: T) => boolean): T[];\r\n    \r\n    removeAll(): T[];\r\n    removeAll(items: T[]): T[];\r\n\r\n    destroy(item: T): void;\r\n    destroy(destroyFunction: (item: T) => boolean): void;\r\n    \r\n    destroyAll(): void;\r\n    destroyAll(items: T[]): void;\r\n\r\n    subscribe(callback: (val: T[]) => void): KnockoutSubscription;\r\n    subscribe(callback: (val: T[]) => void, callbackTarget: any): KnockoutSubscription;\r\n    subscribe(callback: (val: any[]) => void, callbackTarget: any, event: string): KnockoutSubscription;\r\n\r\n    /**\r\n     * Run mutator function that can write to array at some index (`array[index] = value;`)\r\n     * Then notify about observableArray changes\r\n     */\r\n    mutate(mutator: (arrayValue: T[]) => void): void;\r\n\r\n    /**\r\n     * Replace value at some index and return old value\r\n     */\r\n    set(index: number, value: T): T;\r\n}","/**\r\n * Copyright (c) 2016-2017 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\nimport { objectForEach, defineProperty, hasOwnProperty, getPrototypeOf } from \"./common-functions\";\r\nimport { applyExtenders } from \"./property-extenders\";\r\nimport { defineObservableArray } from \"./observable-array\";\r\n\r\nexport function defineObservableProperty(\r\n    instance: Object, key: string | symbol, value: any, deep: boolean\r\n) {\r\n    const observable = applyExtenders(instance, key, ko.observable());\r\n\r\n    let setter = observable as Function;\r\n    \r\n    if (deep) {\r\n        setter = function (newValue: any) {\r\n            observable(prepareReactiveValue(newValue));\r\n        };\r\n    }\r\n\r\n    defineProperty(instance, key, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get: observable,\r\n        set: setter,\r\n    });\r\n    \r\n    setter(value);\r\n}\r\n\r\nexport function prepareReactiveValue(value: any) {\r\n    if (typeof value === \"object\") {\r\n        if (Array.isArray(value) || value === null) {\r\n            // value is Array or null\r\n            return value;\r\n        } else if (value.constructor === Object) {\r\n            // value is plain Object\r\n            return prepareReactiveObject(value); \r\n        } else if (hasOwnProperty(value, \"constructor\")) {\r\n            const prototype = getPrototypeOf(value);\r\n            if (prototype === Object.prototype || prototype === null) {\r\n                // value is plain Object\r\n                return prepareReactiveObject(value);\r\n            }\r\n        }\r\n    }\r\n    // value is primitive, function or class instance\r\n    return value;\r\n}\r\n\r\nconst REACTIVE_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"ko_decorators_reactive\") : \"__ko_decorators_reactive__\";\r\n\r\nexport function prepareReactiveObject(instance: Object) {\r\n    if (!hasOwnProperty(instance, REACTIVE_KEY)) {\r\n        // mark instance as ObservableObject\r\n        defineProperty(instance, REACTIVE_KEY, {\r\n            configurable: true,\r\n            value: void 0,\r\n        });\r\n        // define deep observable properties\r\n        objectForEach(instance, (key, value) => {\r\n            if (Array.isArray(value)) {\r\n                defineObservableArray(instance, key, value, true);\r\n            } else {\r\n                defineObservableProperty(instance, key, value, true);\r\n            }\r\n        });\r\n    }\r\n    return instance;\r\n}","/**\r\n * Copyright (c) 2016-2017 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\nimport { defineProperty, arraySlice } from \"./common-functions\";\r\nimport { EventProperty } from \"./knockout-decorators\";\r\n\r\nexport function defineEventProperty(instance: Object, key: string | symbol) {\r\n    const subscribable = new ko.subscribable<any[]>();\r\n\r\n    const event: EventProperty = function () {\r\n        const eventArgs = arraySlice(arguments);\r\n        subscribable.notifySubscribers(eventArgs);\r\n    } as any;\r\n\r\n    event.subscribe = function (callback: Function) {\r\n        return subscribable.subscribe(function (eventArgs: any[]) {\r\n            callback.apply(null, eventArgs);\r\n        });\r\n    };\r\n\r\n    defineProperty(instance, key, {\r\n        configurable: true,\r\n        value: event,\r\n    });\r\n\r\n    return event;\r\n}","/**\r\n * Copyright (c) 2016-2017 Dmitry Panyushkin\r\n * Available under MIT license\r\n * Version: 0.9.0\r\n */\r\nimport * as ko from \"knockout\";\r\nimport { extendObject, defineProperty, hasOwnProperty, getOwnPropertyDescriptor, arraySlice } from \"./common-functions\";\r\nimport { defineExtenders, applyExtenders } from \"./property-extenders\";\r\nimport { defineObservableProperty, prepareReactiveObject } from \"./observable-property\";\r\nimport { defineObservableArray } from \"./observable-array\";\r\nimport { defineEventProperty } from \"./event-property\";\r\n\r\n/**\r\n * Property decorator that creates hidden (shallow) ko.observable with ES6 getter and setter for it\r\n * If initialized by Array then hidden (shallow) ko.observableArray will be created\r\n */\r\nexport function observable(prototype: Object, key: string | symbol) {\r\n    defineProperty(prototype, key, {\r\n        configurable: true,\r\n        get() {\r\n            throw new Error(\"@observable property '\" + key.toString() + \"' was not initialized\");\r\n        },\r\n        set(value: any) {\r\n            if (Array.isArray(value)) {\r\n                defineObservableArray(this, key, value, false);\r\n            } else {\r\n                defineObservableProperty(this, key, value, false);\r\n            }\r\n        },\r\n    });\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Property decorator that creates hidden (deep) ko.observable with ES6 getter and setter for it\r\n * If initialized by Array then hidden (deep) ko.observableArray will be created\r\n */\r\nexport function reactive(prototype: Object, key: string | symbol) {\r\n    defineProperty(prototype, key, {\r\n        configurable: true,\r\n        get() {\r\n            throw new Error(\"@reactive property '\" + key.toString() + \"' was not initialized\");\r\n        },\r\n        set(value: any) {\r\n            if (Array.isArray(value)) {\r\n                defineObservableArray(this, key, value, true);\r\n            } else {\r\n                defineObservableProperty(this, key, value, true);\r\n            }\r\n        },\r\n    });\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Accessor decorator that wraps ES6 getter to hidden ko.pureComputed\r\n * \r\n * Setter is not wrapped to hidden ko.pureComputed and stays unchanged\r\n *\r\n * But we can still extend getter @computed by extenders like { rateLimit: 500 } \r\n */\r\nexport function computed(prototype: Object, key: string | symbol, desc: PropertyDescriptor) {\r\n    const { get, set } = desc || (desc = getOwnPropertyDescriptor(prototype, key));\r\n    desc.get = function () {\r\n        const computed = applyExtenders(this, key, ko.pureComputed(get, this));\r\n        defineProperty(this, key, {\r\n            configurable: true,\r\n            get: computed,\r\n            set: set,\r\n        });\r\n        return computed();\r\n    };\r\n    return desc;\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Property decorator that creates hidden (shallow) ko.observableArray with ES6 getter and setter for it\r\n */\r\nexport function observableArray(prototype: Object, key: string | symbol) {\r\n    defineProperty(prototype, key, {\r\n        configurable: true,\r\n        get() {\r\n            throw new Error(\"@observableArray property '\" + key.toString() + \"' was not initialized\");\r\n        },\r\n        set(value: any[]) {\r\n            defineObservableArray(this, key, value, false);\r\n        },\r\n    });\r\n}\r\n\r\nexport interface ObservableArray<T> extends Array<T> {\r\n    replace(oldItem: T, newItem: T): void;\r\n\r\n    remove(item: T): T[];\r\n    remove(removeFunction: (item: T) => boolean): T[];\r\n    \r\n    removeAll(): T[];\r\n    removeAll(items: T[]): T[];\r\n\r\n    destroy(item: T): void;\r\n    destroy(destroyFunction: (item: T) => boolean): void;\r\n    \r\n    destroyAll(): void;\r\n    destroyAll(items: T[]): void;\r\n\r\n    subscribe(callback: (val: T[]) => void): KnockoutSubscription;\r\n    subscribe(callback: (val: T[]) => void, callbackTarget: any): KnockoutSubscription;\r\n    subscribe(callback: (val: any[]) => void, callbackTarget: any, event: string): KnockoutSubscription;\r\n\r\n    /**\r\n     * Run mutator function that can write to array at some index (`array[index] = value;`)\r\n     * Then notify about observableArray changes\r\n     */\r\n    mutate(mutator: (arrayValue: T[]) => void): void;\r\n\r\n    /**\r\n     * Replace value at some index and return old value\r\n     */\r\n    set(index: number, value: T): T;\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Apply extenders to decorated @observable\r\n */\r\nexport function extend(extenders: Object): PropertyDecorator;\r\n/**\r\n * Apply extenders to decorated @observable\r\n */\r\nexport function extend(extendersFactory: () => Object): PropertyDecorator;\r\n/**\r\n * Apply extenders to decorated @observable\r\n * @extendersOrFactory { Object | Function } Knockout extenders definition or factory that produces definition\r\n */\r\nexport function extend(extendersOrFactory: Object | Function) {\r\n    return function (prototype: Object, key: string | symbol) {\r\n        defineExtenders(prototype, key, extendersOrFactory);\r\n    }\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\nexport interface ComponentConstructor {\r\n    new (\r\n        params?: any,\r\n        element?: Node,\r\n        templateNodes?: Node[]\r\n    ): any;\r\n}\r\n\r\nexport type ComponentDecorator = (constructor: ComponentConstructor) => void;\r\n\r\nexport type TemplateConfig = (\r\n    string\r\n    | Node[] \r\n    | DocumentFragment \r\n    | { require: string }\r\n    | { element: string | Node }\r\n);\r\n\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n    name: string,\r\n    options?: Object\r\n): ComponentDecorator;\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    options?: Object\r\n): ComponentDecorator;\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    styles: string | string[],\r\n    options?: Object\r\n): ComponentDecorator;\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n * @param name { String } Name of component\r\n * @param template { Any } Knockout template definition\r\n * @param styles { Any } Ignored parameter (used for `require()` styles by webpack etc.)\r\n * @param options { Object } Another options that passed directly to `ko.components.register()`\r\n */\r\nexport function component(\r\n    name: string,\r\n    template?: any,\r\n    styles?: any,\r\n    options?: Object\r\n) {\r\n    if (options === void 0) {\r\n        if (styles === void 0) {\r\n            if (typeof template === \"object\"\r\n                && template.constructor === Object\r\n                && !(\"require\" in template)\r\n                && !(\"element\" in template)\r\n            ) {\r\n                options = template;\r\n                template = void 0;\r\n            }\r\n        } else if (typeof styles === \"object\") {\r\n            options = styles;\r\n            styles = void 0;\r\n        }\r\n    }\r\n\r\n    return function (constructor: ComponentConstructor) {\r\n        ko.components.register(name, extendObject({\r\n            viewModel: constructor.length < 2 ? constructor : {\r\n                createViewModel(params, { element, templateNodes }) {\r\n                    return new constructor(params, element, templateNodes);\r\n                }\r\n            },\r\n            template: template || \"<!---->\",\r\n            synchronous: true,\r\n        }, options));\r\n    }\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Like https://github.com/jayphelps/core-decorators.js @autobind but less smart and complex\r\n * Do NOT use with ES6 inheritance!\r\n */\r\nexport function autobind(prototype: Object, key: string | symbol, desc: PropertyDescriptor) {\r\n    const { value, configurable, enumerable } = desc || (desc = getOwnPropertyDescriptor(prototype, key));\r\n    return {\r\n        configurable: configurable,\r\n        enumerable: enumerable,\r\n        get() {\r\n            if (this === prototype) {\r\n                return value;\r\n            }\r\n            const bound = value.bind(this);\r\n            defineProperty(this, key, {\r\n                configurable: true,\r\n                value: bound,\r\n            });\r\n            return bound;\r\n        }\r\n    } as PropertyDescriptor;\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Define hidden ko.subscribable, that notifies subscribers when decorated method is invoked\r\n */\r\nexport function event(prototype: Object, key: string | symbol): void {\r\n    defineProperty(prototype, key, {\r\n        configurable: true,\r\n        get() {\r\n            return defineEventProperty(this, key);\r\n        },\r\n    })\r\n}\r\n\r\nexport type EventProperty = Function & {\r\n    subscribe(callback: Function): KnockoutSubscription;\r\n};\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Subscribe callback to `@observable` or `@computed` dependency changes or to some `@event`\r\n */\r\nexport function subscribe<T>(\r\n    dependencyOrEvent: () => T, \r\n    callback: (value: T) => void,\r\n    options?: { once?: boolean, event?: string }\r\n): KnockoutSubscription;\r\n/**\r\n * Subscribe callback to some `@event`\r\n */\r\nexport function subscribe<T>(\r\n    event: (arg: T) => void, \r\n    callback: (arg: T) => void,\r\n    options?: { once?: boolean }\r\n): KnockoutSubscription;\r\n/**\r\n * Subscribe callback to some `@event`\r\n */\r\nexport function subscribe<T1, T2>(\r\n    event: (arg1: T1, arg2: T2) => void, \r\n    callback: (arg1: T1, arg2: T2) => void,\r\n    options?: { once?: boolean }\r\n): KnockoutSubscription;\r\n/**\r\n * Subscribe callback to some `@event`\r\n */\r\nexport function subscribe<T1, T2, T3>(\r\n    event: (arg1: T1, arg2: T2, arg3: T3, ...args: any[]) => void, \r\n    callback: (arg1: T1, arg2: T2, arg3: T3, ...args: any[]) => void,\r\n    options?: { once?: boolean }\r\n): KnockoutSubscription;\r\n/**\r\n * Subscribe callback to `@observable` or `@computed` dependency changes or to some `@event`\r\n */\r\nexport function subscribe<T>(\r\n    dependencyOrEvent: Function,\r\n    callback: (...args: any[]) => void,\r\n    options?: { once?: boolean, event?: string }\r\n): KnockoutSubscription {\r\n    const once = options && options.once || false;\r\n    \r\n    if (hasOwnProperty(dependencyOrEvent, \"subscribe\")) {\r\n        // subscribe to @event\r\n        const event = dependencyOrEvent as EventProperty;\r\n\r\n        if (once) {\r\n            const subscription = event.subscribe(function () {\r\n                subscription.dispose();\r\n                callback.apply(null, arguments);\r\n            });\r\n            return subscription;\r\n        } else {\r\n            return event.subscribe(callback);\r\n        }\r\n    } else {\r\n        // subscribe to @observable, @reactive or @computed\r\n        const event = options && options.event || \"change\";\r\n\r\n        const computed = ko.computed(dependencyOrEvent as () => T);\r\n        \r\n        let handler: (value: T) => void;\r\n        if (once) {\r\n            handler = function () {\r\n                subscription.dispose();\r\n                callback.apply(null, arguments);\r\n            };\r\n        } else {\r\n            handler = callback;\r\n        }\r\n\r\n        const subscription = computed.subscribe(handler, null, event);\r\n        \r\n        const originalDispose = subscription.dispose;\r\n        // dispose hidden computed with subscription\r\n        subscription.dispose = function () {\r\n            originalDispose.call(this);\r\n            computed.dispose();\r\n        };\r\n\r\n        return subscription;\r\n    }\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap(instance: Object, key: string | symbol): any;\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap<T>(instance: Object, key: string | symbol): KnockoutObservable<T>;\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap(instance: Object, key: string | symbol) {\r\n    if (!hasOwnProperty(instance, key)) {\r\n        // invoke getter on instance.__proto__ that defines property on instance\r\n        instance[key];\r\n    }\r\n    return getOwnPropertyDescriptor(instance, key).get;\r\n}","import * as ko from \"knockout\";\r\n\r\nexport const extendObject = ko.utils.extend;\r\nexport const objectForEach = ko.utils.objectForEach;\r\nexport const defineProperty = Object.defineProperty.bind(Object);\r\nexport const getPrototypeOf = Object.getPrototypeOf.bind(Object);\r\nexport const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor.bind(Object);\r\nexport const hasOwnProperty = Function.prototype.call.bind(Object.prototype.hasOwnProperty);\r\nexport const arraySlice = Function.prototype.call.bind(Array.prototype.slice);"],"names":["instance","key","target","dictionary","EXTENDERS_KEY","extenders","forEach","extender","koExtender","Function","call","extend","prototype","extendersOrFactory","hasOwnProperty","extendObject","objectForEach","push","value","deep","newValue","lastValue","obsArray","peek","Array","isArray","allMethods","fnName","i","length","prepareReactiveValue","patchArrayMethods","insideObsArray","array","arrayMethods","deepArrayMethods","allArrayMethods","defineProperty","configurable","apply","arguments","result","observableArrayMethods","deepObservableArrayMethods","allObservableArrayMethods","args","arraySlice","unshift","splice","oldItem","newItem","replace","mutator","valueWillMutate","valueHasMutated","index","applyExtenders","ko.observableArray","enumerable","get","set","setter","observable","ko.observable","constructor","Object","prepareReactiveObject","getPrototypeOf","REACTIVE_KEY","defineObservableArray","defineObservableProperty","subscribable","ko.subscribable","event","eventArgs","notifySubscribers","subscribe","callback","Error","toString","this","desc","_a","computed","ko.pureComputed","defineExtenders","name","template","styles","options","ko.components","register","viewModel","createViewModel","params","element","templateNodes","synchronous","bound","bind","defineEventProperty","dependencyOrEvent","once","event_1","subscription_1","dispose","event_2","computed_1","ko.computed","handler","subscription_2","originalDispose_1","getOwnPropertyDescriptor","ko.utils","slice","Symbol"],"mappings":"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"}