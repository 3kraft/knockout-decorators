{"version":3,"file":null,"sources":["../src/knockout-decorators.ts"],"sourcesContent":["/**\r\n * Copyright (c) 2016 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\n\r\nconst assign = ko.utils.extend;\r\nconst objectForEach = ko.utils.objectForEach;\r\nconst defProp = Object.defineProperty.bind(Object);\r\nconst getDescriptor = Object.getOwnPropertyDescriptor.bind(Object);\r\nconst hasOwnProperty = Function.prototype.call.bind(Object.prototype.hasOwnProperty);\r\nconst slice = Function.prototype.call.bind(Array.prototype.slice);\r\n\r\n/*===========================================================================*/\r\n\r\nexport interface ComponentConstructor {\r\n    new (\r\n        params?: any,\r\n        element?: Node,\r\n        templateNodes?: Node[]\r\n    ): any;\r\n}\r\n\r\nexport type ComponentDecorator = (constructor: ComponentConstructor) => void;\r\n\r\nexport type TemplateConfig = (\r\n    string\r\n    | Node[] \r\n    | DocumentFragment \r\n    | { require: string }\r\n    | { element: string | Node }\r\n);\r\n\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n    name: string,\r\n    options?: Object\r\n): ComponentDecorator;\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    options?: Object\r\n): ComponentDecorator;\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    styles: string | string[],\r\n    options?: Object\r\n): ComponentDecorator;\r\n\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n * @param name { String } Name of component\r\n * @param template { Any } Knockout template definition\r\n * @param styles { Any } Ignored parameter (used for `require()` styles by webpack etc.)\r\n * @param options { Object } Another options that passed directly to `ko.components.register()`\r\n */\r\nexport function component(\r\n    name: string,\r\n    template?: any,\r\n    styles?: any,\r\n    options?: Object\r\n) {\r\n    if (options === void 0) {\r\n        if (styles === void 0) {\r\n            if (typeof template === \"object\"\r\n                && template.constructor === Object\r\n                && !(\"require\" in template)\r\n                && !(\"element\" in template)\r\n            ) {\r\n                options = template;\r\n                template = void 0;\r\n            }\r\n        } else if (typeof styles === \"object\") {\r\n            options = styles;\r\n            styles = void 0;\r\n        }\r\n    }\r\n\r\n    return function (constructor: ComponentConstructor) {\r\n        ko.components.register(name, assign({\r\n            viewModel: constructor.length < 2 ? constructor : {\r\n                createViewModel(params, { element, templateNodes }) {\r\n                    return new constructor(params, element, templateNodes);\r\n                }\r\n            },\r\n            template: template || \"<!---->\",\r\n            synchronous: true,\r\n        }, options));\r\n    }\r\n}\r\n\r\n/*===========================================================================*/\r\n\r\n/**\r\n * Property decorator that creates hidden ko.observable with ES6 getter and setter for it\r\n */\r\nexport function observable(prototype: Object, key: string | symbol) {\r\n    defProp(prototype, key, {\r\n        configurable: true,\r\n        get() {\r\n            const observable = applyExtenders(this, key, ko.observable());\r\n            defProp(this, key, {\r\n                configurable: true,\r\n                enumerable: true,\r\n                get: observable,\r\n                set: observable,\r\n            });\r\n            return observable();\r\n        },\r\n        set(value) {\r\n            const observable = applyExtenders(this, key, ko.observable());\r\n            defProp(this, key, {\r\n                configurable: true,\r\n                enumerable: true,\r\n                get: observable,\r\n                set: observable,\r\n            });\r\n            observable(value);\r\n        },\r\n    });\r\n}\r\n\r\n/*===========================================================================*/\r\n\r\n/**\r\n * Accessor decorator that wraps ES6 getter to hidden ko.pureComputed\r\n * \r\n * Setter is not wrapped to hidden ko.pureComputed and stays unchanged\r\n *\r\n * But we can still extend getter @computed by extenders like { rateLimit: 500 } \r\n */\r\nexport function computed(prototype: Object, key: string | symbol, desc: PropertyDescriptor) {\r\n    const { get, set } = desc || (desc = getDescriptor(prototype, key));\r\n    desc.get = function () {\r\n        const computed = applyExtenders(this, key, ko.pureComputed(get, this));\r\n        defProp(this, key, {\r\n            configurable: true,\r\n            get: computed,\r\n            set: set\r\n        });\r\n        return computed();\r\n    };\r\n    return desc;\r\n    // TODO: make @computed extendable (by @extend decorator)\r\n}\r\n\r\n/*===========================================================================*/\r\n\r\ntype ObsArray = KnockoutObservableArray<any> & { [fnName: string]: Function };\r\n\r\nconst arrayMethods = [\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"];\r\nconst observableArrayMethods = [\"remove\", \"removeAll\", \"destroy\", \"destroyAll\", \"replace\", \"subscribe\"];\r\n\r\nfunction defObservableArray(instance: Object, key: string | symbol) {\r\n    const obsArray = applyExtenders(instance, key, ko.observableArray()) as ObsArray;\r\n    \r\n    let insideObsArray = false;\r\n\r\n    defProp(instance, key, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get: obsArray,\r\n        set(value: any[]) {\r\n            const lastValue = obsArray.peek();\r\n            // if we got new value\r\n            if (lastValue !== value) {\r\n                if (Array.isArray(lastValue)) {\r\n                    // if lastValue array methods were already patched\r\n                    if (hasOwnProperty(lastValue, \"subscribe\")) {\r\n                        // clear patched array methods on lastValue (see unit tests)\r\n                        clearArrayMethods(lastValue);\r\n                    }\r\n                }\r\n                if (Array.isArray(value)) {\r\n                    // if new value array methods were already connected with another @observableArray\r\n                    if (hasOwnProperty(value, \"subscribe\")) {\r\n                        // clone new value to prevent corruption of another @observableArray (see unit tests)\r\n                        value = slice(value);\r\n                    }\r\n                    // call ko.observableArray.fn[fnName] instead of Array.prototype[fnName]\r\n                    patchArrayMethods(value);\r\n                }\r\n            }\r\n            insideObsArray = true;\r\n            obsArray(value);\r\n            insideObsArray = false;\r\n        }\r\n    });\r\n\r\n    function patchArrayMethods(array: any[]) {\r\n        arrayMethods.forEach(fnName => defProp(array, fnName, {\r\n            configurable: true,\r\n            value() {\r\n                if (insideObsArray) {\r\n                    return Array.prototype[fnName].apply(array, arguments);\r\n                }\r\n                insideObsArray = true;\r\n                const result = obsArray[fnName].apply(obsArray, arguments);\r\n                insideObsArray = false;\r\n                return result;\r\n            }\r\n        }));\r\n        observableArrayMethods.forEach(fnName => defProp(array, fnName, {\r\n            configurable: true,\r\n            value() {\r\n                insideObsArray = true;\r\n                const result = obsArray[fnName].apply(obsArray, arguments);\r\n                insideObsArray = false;\r\n                return result;\r\n            }\r\n        }));\r\n    }\r\n}\r\n\r\n// moved outside of defObservableArray function to prevent creation of unnecessary closure\r\nfunction clearArrayMethods(array: any[]) {\r\n    arrayMethods.forEach(fnName => {\r\n        delete array[fnName]; \r\n    });\r\n    observableArrayMethods.forEach(fnName => {\r\n        delete array[fnName]; \r\n    });\r\n}\r\n\r\n/**\r\n * Property decorator that creates hidden ko.observableArray with ES6 getter and setter for it\r\n */\r\nexport function observableArray(prototype: Object, key: string | symbol) {\r\n    defProp(prototype, key, {\r\n        configurable: true,\r\n        get() {\r\n            defObservableArray(this, key);\r\n            this[key] = [];\r\n            return this[key];\r\n        },\r\n        set(value: any[]) {\r\n            defObservableArray(this, key);\r\n            this[key] = value;\r\n        },\r\n    });\r\n}\r\n\r\nexport interface ObservableArray<T> extends Array<T> {\r\n    replace(oldItem: T, newItem: T): void;\r\n\r\n    remove(item: T): T[];\r\n    remove(removeFunction: (item: T) => boolean): T[];\r\n    \r\n    removeAll(): T[];\r\n    removeAll(items: T[]): T[];\r\n\r\n    destroy(item: T): void;\r\n    destroy(destroyFunction: (item: T) => boolean): void;\r\n    \r\n    destroyAll(): void;\r\n    destroyAll(items: T[]): void;\r\n\r\n    subscribe(callback: (val: T[]) => void): KnockoutSubscription;\r\n    subscribe(callback: (val: T[]) => void, callbackTarget: any): KnockoutSubscription;\r\n    subscribe(callback: (val: any[]) => void, callbackTarget: any, event: string): KnockoutSubscription;\r\n}\r\n\r\n/*===========================================================================*/\r\n\r\nconst DECORATORS_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"ko_decorators\") : \"__ko_decorators__\";\r\n\r\ntype Extender = Object | Function;\r\n\r\ninterface MetaData {\r\n    [propName: string]: Extender[];\r\n}\r\n\r\nfunction getOrCreateMetaData(prototype: Object) {\r\n    let metaData: MetaData = prototype[DECORATORS_KEY];\r\n    if (!prototype.hasOwnProperty(DECORATORS_KEY)) {\r\n        // clone MetaData from base class prototype\r\n        prototype[DECORATORS_KEY] = metaData = assign({}, metaData) as MetaData;\r\n        // clone extenders arrays for each property key\r\n        objectForEach(metaData, (key, extenders) => {\r\n            metaData[key] = [...extenders];\r\n        });\r\n    }\r\n    return metaData;\r\n}\r\n\r\nfunction getOrCreateExtenders(metaData: MetaData, key: string | symbol) {\r\n    return metaData[key] || (metaData[key] = []);\r\n}\r\n\r\nfunction applyExtenders(\r\n    instance: Object, key: string | symbol,\r\n    target: KnockoutObservable<any> | KnockoutComputed<any>\r\n) {\r\n    const metaData: MetaData = instance[DECORATORS_KEY];\r\n    const extenders = metaData && metaData[key];\r\n    if (extenders) {\r\n        extenders.forEach(extender => {\r\n            const koExtender = extender instanceof Function\r\n                ? extender.call(instance) : extender;\r\n\r\n            target = target.extend(koExtender);\r\n        });\r\n    }\r\n    return target;\r\n}\r\n\r\n/**\r\n * Apply extenders to decorated @observable\r\n */\r\nexport function extend(extenders: Object): PropertyDecorator;\r\nexport function extend(extendersFactory: () => Object): PropertyDecorator;\r\n\r\n/**\r\n * Apply extenders to decorated @observable\r\n * @extendersOrFactory { Object | Function } Knockout extenders definition or factory that produces definition\r\n */\r\nexport function extend(extendersOrFactory: Object | Function) {\r\n    return function (prototype: Object, key: string | symbol) {\r\n        const medaData = getOrCreateMetaData(prototype);\r\n        const extenders = getOrCreateExtenders(medaData, key);\r\n        extenders.push(extendersOrFactory);\r\n    }\r\n}\r\n\r\n/*===========================================================================*/\r\n\r\n/**\r\n * Like https://github.com/jayphelps/core-decorators.js @autobind but less smart and complex\r\n * Do NOT use with ES6 inheritance!\r\n */\r\nexport function autobind(prototype: Object, key: string | symbol, desc: PropertyDescriptor) {\r\n    const { value, configurable, enumerable } = desc || (desc = getDescriptor(prototype, key));\r\n    return {\r\n        configurable: configurable,\r\n        enumerable: enumerable,\r\n        get() {\r\n            if (this === prototype) {\r\n                return value;\r\n            }\r\n            const bound = value.bind(this);\r\n            defProp(this, key, {\r\n                configurable: true,\r\n                value: bound,\r\n            });\r\n            return bound;\r\n        }\r\n    } as PropertyDescriptor;\r\n}\r\n\r\n/*===========================================================================*/\r\n\r\n/**\r\n * Subscribe callback to dependency changes\r\n */\r\nexport function subscribe<T>(\r\n    getDependency: () => T, \r\n    callback: (value: T) => void,\r\n    options?: { once?: boolean, event?: string }\r\n): KnockoutSubscription {\r\n    const once = options && options.once || false;\r\n    const event = options && options.event || \"change\";\r\n\r\n    const dependency = ko.computed(getDependency);\r\n    \r\n    const subscription = dependency.subscribe(callback, null, event);\r\n    \r\n    const originalDispose = subscription.dispose;\r\n    // dispose hidden computed with subscription\r\n    subscription.dispose = function () {\r\n        originalDispose.call(this);\r\n        dependency.dispose();\r\n    };\r\n\r\n    if (once) {\r\n        dependency.subscribe(() => {\r\n            subscription.dispose();\r\n        });\r\n    }\r\n    return subscription;\r\n}\r\n\r\n/*===========================================================================*/\r\n\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap(instance: Object, key: string | symbol): any;\r\nexport function unwrap<T>(instance: Object, key: string | symbol): KnockoutObservable<T>;\r\n\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap(instance: Object, key: string | symbol) {\r\n    if (!hasOwnProperty(instance, key)) {\r\n        // invoke getter on instance.__proto__ that defines property on instance\r\n        instance[key];\r\n    }\r\n    return getDescriptor(instance, key).get;\r\n}"],"names":["name","template","styles","options","constructor","Object","ko.components","register","assign","viewModel","length","createViewModel","params","_a","element","templateNodes","synchronous","prototype","key","defProp","configurable","get","observable","applyExtenders","this","ko.observable","enumerable","set","value","desc","computed","ko.pureComputed","instance","array","arrayMethods","forEach","fnName","insideObsArray","Array","apply","arguments","result","obsArray","observableArrayMethods","ko.observableArray","lastValue","peek","isArray","hasOwnProperty","clearArrayMethods","slice","patchArrayMethods","defObservableArray","metaData","DECORATORS_KEY","objectForEach","extenders","target","extender","koExtender","Function","call","extend","extendersOrFactory","medaData","getOrCreateMetaData","getOrCreateExtenders","push","bound","bind","getDependency","callback","once","event","dependency","ko.computed","subscription","subscribe","originalDispose","dispose","getDescriptor","ko.utils","defineProperty","getOwnPropertyDescriptor","Symbol"],"mappings":"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"}