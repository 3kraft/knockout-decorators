{"version":3,"file":null,"sources":["../src/knockout-decorators.ts"],"sourcesContent":["import * as ko from \"knockout\";\r\n\r\nexport interface ComponentConstructor {\r\n    new (\r\n        params?: any,\r\n        element?: Node,\r\n        templateNodes?: Node[]\r\n    ): any;\r\n}\r\n\r\nexport type ComponentDecorator = (constructor: ComponentConstructor) => void;\r\n\r\nexport type TemplateConfig = (\r\n    string\r\n    | Node[] \r\n    | DocumentFragment \r\n    | { require: string }\r\n    | { element: string | Node }\r\n);\r\n\r\nconst extend = ko.utils.extend;\r\nconst objectForEach = ko.utils.objectForEach;\r\nconst defProp = Object.defineProperty.bind(Object);\r\nconst getDescriptor = Object.getOwnPropertyDescriptor.bind(Object);\r\n\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n    name: string,\r\n    options?: Object\r\n): ComponentDecorator;\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    options?: Object\r\n): ComponentDecorator;\r\nexport function component(\r\n    name: string,\r\n    template: TemplateConfig,\r\n    styles: string | string[],\r\n    options?: Object\r\n): ComponentDecorator;\r\n\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n    name: string,\r\n    template?: any,\r\n    styles?: any,\r\n    options?: Object\r\n) {\r\n    if (options === void 0) {\r\n        if (styles === void 0) {\r\n            if (typeof template === \"object\"\r\n                && template.constructor === Object\r\n                && !(\"require\" in template)\r\n                && !(\"element\" in template)\r\n            ) {\r\n                options = template;\r\n                template = void 0;\r\n            }\r\n        } else if (typeof styles === \"object\") {\r\n            options = styles;\r\n            styles = void 0;\r\n        }\r\n    }\r\n\r\n    return function (constructor: ComponentConstructor) {\r\n        ko.components.register(name, extend({\r\n            viewModel: constructor.length < 2 ? constructor : {\r\n                createViewModel(params, { element, templateNodes }) {\r\n                    return new constructor(params, element, templateNodes);\r\n                }\r\n            },\r\n            template: template || \"<!---->\",\r\n            synchronous: true,\r\n        }, options));\r\n    }\r\n}\r\n\r\nconst DECORATORS_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"knockout_decorators\") : \"__knockout_decorators_\";\r\n\r\nconst SUBSCRIPTIONS_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"knockout_decorators_subscriptions\") : \"__knockout_decorators_subscriptions_\";\r\n\r\nconst DISPOSABLE_KEY = typeof Symbol !== \"undefined\"\r\n    ? Symbol(\"knockout_decorators_disposable\") : \"__knockout_decorators_disposable_\";\r\n\r\nconst enum DecoratorType {\r\n    Extend, Subscribe,\r\n}\r\n\r\ninterface Decorator {\r\n    type: DecoratorType,\r\n    value: any,\r\n    dispose?: boolean,\r\n}\r\n\r\ninterface MetaData {\r\n    [propName: string]: Decorator[],\r\n}\r\n\r\ninterface Disposable {\r\n    dispose(): void,\r\n}\r\n\r\nfunction getMetaData(prototype: Object) {\r\n    let metaData: MetaData = prototype[DECORATORS_KEY];\r\n    if (!prototype.hasOwnProperty(DECORATORS_KEY)) {\r\n        prototype[DECORATORS_KEY] = metaData = extend({}, metaData);\r\n        objectForEach(metaData, (key, decorators) => {\r\n            metaData[key] = [...decorators];\r\n        });\r\n    }\r\n    return metaData;\r\n}\r\n\r\nfunction getDecorators(metaData: MetaData, key: string | symbol) {\r\n    return metaData[key] || (metaData[key] = []);\r\n}\r\n\r\nfunction getSubscriptions(instance: Object): Disposable[] {\r\n    return instance[SUBSCRIPTIONS_KEY] || (instance[SUBSCRIPTIONS_KEY] = []);\r\n}\r\n\r\nfunction applyDecorators(\r\n    instance: Object, key: string | symbol,\r\n    target: ko.Observable<any> | ko.PureComputed<any>\r\n) {\r\n    let metaData: MetaData = instance[DECORATORS_KEY];\r\n    let decorators = metaData && metaData[key];\r\n    if (decorators) {\r\n        decorators.forEach(d => {\r\n            switch (d.type) {\r\n                case DecoratorType.Extend:\r\n                    let extender = d.value as Object;\r\n                    target = target.extend(extender);\r\n                    break;\r\n                case DecoratorType.Subscribe:\r\n                    let callback = d.value as Function;\r\n                    let subscription = target.subscribe(callback.bind(instance));\r\n                    if (d.dispose) {\r\n                        getSubscriptions(instance).push(subscription);\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    return target;\r\n}\r\n\r\nfunction redefineDispose(prototype: Object) {\r\n    if (prototype[DISPOSABLE_KEY]) { return; }\r\n    prototype[DISPOSABLE_KEY] = true;\r\n\r\n    let original = prototype['dispose'];\r\n    prototype['dispose'] = function dispose() {\r\n        let disposables = this[SUBSCRIPTIONS_KEY] as Disposable[];\r\n        if (disposables) {\r\n            disposables.forEach(s => { s.dispose(); });\r\n        }\r\n        if (original) {\r\n            return original.apply(this, arguments);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Property decorator that creates hidden ko.observable with ES6 getter and setter for it\r\n */\r\nexport function observable(prototype: Object, key: string | symbol) {\r\n    defProp(prototype, key, {\r\n        get() {\r\n            const observable = applyDecorators(this, key, ko.observable());\r\n            defProp(this, key, { get: observable, set: observable });\r\n            return observable();\r\n        },\r\n        set(value) {\r\n            const observable = applyDecorators(this, key, ko.observable(value));\r\n            defProp(this, key, { get: observable, set: observable });\r\n        },\r\n    });\r\n}\r\n\r\n/**\r\n * Accessor decorator that wraps ES6 getter and setter to hidden ko.pureComputed\r\n */\r\nexport function computed(prototype: Object, key: string | symbol) {\r\n    const { get, set } = getDescriptor(prototype, key);\r\n    if (!set) {\r\n        defProp(prototype, key, {\r\n            get() {\r\n                const computed = applyDecorators(this, key, ko.pureComputed(get, this));\r\n                defProp(this, key, { get: computed });\r\n                return computed();\r\n            }\r\n        });\r\n    } else {\r\n        defProp(prototype, key, {\r\n            get() {\r\n                const computed = applyDecorators(this, key,\r\n                    ko.pureComputed({ read: get, write: set, owner: this })\r\n                );\r\n                defProp(this, key, { get: computed, set: computed });\r\n                return computed();\r\n            },\r\n            set(value) {\r\n                const computed = applyDecorators(this, key,\r\n                    ko.pureComputed({ read: get, write: set, owner: this })\r\n                );\r\n                defProp(this, key, { get: computed, set: computed });\r\n                computed(value);\r\n            },\r\n        });\r\n    }\r\n}\r\n\r\nexport function subscribe(callback: (value: any) => void, autoDispose?: boolean): PropertyDecorator;\r\nexport function subscribe(targetOrCallback: string | symbol, autoDispose?: boolean): PropertyDecorator;\r\nexport function subscribe(targetOrCallback: string | symbol, autoDispose?: boolean): MethodDecorator;\r\n\r\n/**\r\n * Subscribe to observable or computed by name or by specifying callback explicitely\r\n * @param targetOrCallback { String | Function } name of callback or callback itself\r\n * when observable is decorated and name of observable property when callback is decorated\r\n * @param autoDispose { boolean } if true then subscription will be disposed when entire ViewModel is disposed\r\n */\r\nexport function subscribe(targetOrCallback: string | symbol | Function, autoDispose = true) {\r\n    return function (prototype: Object, key: string | symbol) {\r\n        let { value, get } = getDescriptor(prototype, key);\r\n        let target: string | symbol, callback: Function;\r\n        if (typeof value === \"function\") {\r\n            if (typeof targetOrCallback === \"string\" || typeof targetOrCallback === \"symbol\") {\r\n                target = targetOrCallback;                      // @subscribe(\"target\")\r\n                callback = value;                               // callback(value) {}    \r\n            } else {\r\n                throw new Error(\"Subscription target should be a key in decorated ViewModel\");\r\n            }\r\n        } else if (typeof get === \"function\") {\r\n            if (typeof targetOrCallback === \"function\") {\r\n                target = key;                                   // @subscribe(ViewModel.prototype.callback)\r\n                callback = targetOrCallback;                    // @observable target;\r\n            } else if (typeof targetOrCallback === \"string\" || typeof targetOrCallback === \"symbol\") {\r\n                target = key;                                   // @subscribe(\"callback\")\r\n                callback = prototype[targetOrCallback];         // @observable target;\r\n            } else {\r\n                throw new Error(\"Subscription callback should be a function or key in decorated ViewModel\");\r\n            }\r\n        }\r\n        getDecorators(getMetaData(prototype), target).push({\r\n            type: DecoratorType.Subscribe,\r\n            value: callback,\r\n            dispose: autoDispose,\r\n        });\r\n        if (autoDispose) {\r\n            redefineDispose(prototype);\r\n        }\r\n    }\r\n}"],"names":["name","template","styles","options","constructor","Object","ko","components","register","extend","viewModel","length","createViewModel","params","_a","element","templateNodes","synchronous","prototype","metaData","DECORATORS_KEY","hasOwnProperty","objectForEach","key","decorators","instance","SUBSCRIPTIONS_KEY","target","forEach","d","type","DecoratorType","Extend","extender","value","Subscribe","callback","subscription","subscribe","bind","dispose","getSubscriptions","push","DISPOSABLE_KEY","original","disposables","this","s","apply","arguments","defProp","get","observable","applyDecorators","set","computed","pureComputed","read","write","owner","targetOrCallback","autoDispose","Error","getDecorators","getMetaData","redefineDispose","utils","defineProperty","getDescriptor","getOwnPropertyDescriptor","Symbol"],"mappings":"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"}